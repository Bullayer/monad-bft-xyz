# Rayon 学习笔记

## 什么是 Rayon？

Rayon 是 Rust 的**数据并行库**，可以把**顺序计算变成并行计算**。

```txt
顺序执行：  [任务1] → [任务2] → [任务3] → [任务4]
            耗时: 1s + 1s + 1s + 1s = 4s

并行执行：  [任务1] ─┬─ [任务3]
            [任务2] ─┴─ [任务4]
            耗时: 2s (假设 2 个 CPU 核心)
```

---

## 核心特性

### 1. 工作窃取 (Work-Stealing)

```txt
线程 1:  [██████░░░░░░░░░░]  任务多
线程 2:  [██░░░░░░░░░░░░░░]  任务少

空闲时:
线程 2 去偷线程 1 的任务来执行
[██████░░░░░░░░░░░]  ← 线程 2 偷走一半
[██░░░│░░░░░░░░░░░░]
      ↑
   被偷走的任务
```

**好处**：自动平衡负载，不需要手动分配任务。

---

### 2. 全局线程池

```rust
// 设置全局线程池（8 个线程）
build_global().expect("Failed to build rayon global thread pool");

// 之后所有并行操作都使用这个线程池
```

---

## Rayon 实现原理

### 1. 整体架构

```txt
┌─────────────────────────────────────────────────────────────────┐
│                         应用程序代码                              │
│              par_iter().map(|x| f(x)).collect()                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    并行迭代器 (Parallel Iterator)                 │
│   par_iter() 将数据分成多个 "slice"                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    工作分解 (Work Division)                      │
│   把大任务拆分成小任务 (job stealing 的基础)                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   调度器 (Scheduler)                             │
│   管理任务队列，执行任务窃取                                        │
│   ├── 本地队列 (per-thread deque)                                │
│   └── 全局队列                                                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   线程池 (Thread Pool)                           │
│   多个工作线程并行执行任务                                          │
│   └── work-stealing 算法                                         │
└─────────────────────────────────────────────────────────────────┘
```

---

### 2. 工作分解 (Work Division)

Rayon 如何把大任务拆分成小任务：

```rust
// 示例：处理 10000 个元素
let data = vec![0; 10000];

data.par_iter().for_each(|x| {
    process(*x);
});

// Rayon 的分解过程：
//
// 初始:  [░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]
//         (10000 个元素)
//
// 第1层: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░]
//         (2 个任务，每个 5000 元素)
//
// 第2层: [█████░░░░░░░░█████░░░░░░░░█████░░░░░░░░█████░░░░░░░░░]
//         (4 个任务，每个 2500 元素)
//
// 第3层: [███░░░███░░░███░░░███░░░███░░░███░░░███░░░███░░░███░░]
//         (8 个任务，每个 1250 元素)
//
// ... 直到任务足够小
//
// 最终:  [▓▓░░▓▓░░▓▓░░▓▓░░▓▓░░▓▓░░▓▓░░▓▓░░▓▓░░▓▓░░▓▓░░▓▓░░▓▓░░]
//         (多个小任务，适合并行执行)
```

**分解策略**：

- 二分法递归划分
- 直到任务大小 ≈ 最小粒度 (min_len)
- 默认最小粒度 ≈ 1024 个元素

---

### 3. 工作窃取算法 (Work-Stealing)

**核心思想**：每个线程有自己的双端队列，空闲时从其他线程偷任务。

```txt
┌─────────────────────────────────────────────────────────────────┐
│                    工作窃取流程                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  初始状态：                                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Thread 0 deque:  [T1, T2, T3, T4, T5, T6, T7, T8]      │   │
│  │  Thread 1 deque:  [T9, T10]                             │   │
│  │  Thread 2 deque:  [T11]                                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                │
│  Thread 1 完成自己的任务：                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Thread 0 deque:  [T1, T2, T3, T4, T5, T6, T7, T8]      │   │
│  │  Thread 1 deque:  []                                    │   │
│  │  Thread 2 deque:  [T11]                                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                │
│  Thread 1 开始窃取：                                             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Thread 0 deque:  [T1, T2, T3, T4]   ◄── 偷走一半        │    │
│  │  Thread 1 deque:  [T5, T6, T7, T8]   ◄── 偷来的任务       │   │
│  │  Thread 2 deque:  [T11]                                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                │
│  窃取原则：                                                      │
│  1. 从队列尾部偷（减少与原线程冲突）                                 │
│  2. 偷走一半任务（平衡负载）                                        │
│  3. 只在本地队列空时才窃取                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**双端队列操作**：

```txt
┌─────────────────────────────────────────────────────────────────┐
│                   双端队列 (Deque) 操作                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│      push_back()  ──►  [T1, T2, T3, T4, T5, T6]  ◄─── pop_back()│
│      (添加任务)              ▲               (本地取任务)          │
│                            │                                    │
│                     本地线程从这里取                               │
│                                                                 │
│      ─────────────────────────────────────────────────────────  │
│                                                                 │
│      steal()  ──────►  [T1, T2, T3, T4, T5, T6]  ◄─── pop()     │
│      (偷任务)                  ▲               (窃取任务)         │
│                                │                                │
│                       其他线程从这里偷                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**窃取算法代码**：

```rust
fn steal_from(thread: &Thread) -> Option<Task> {
    let deque = &thread.deque;
    let mut rng = rand::thread_rng();

    loop {
        // 1. 随机选择一个受害线程
        let victim = pick_random_thread_except_current();

        // 2. 尝试从 victim 的队列尾部偷任务
        match victim.deque.steal() {
            Steal::Success(task) => return Some(task),
            Steal::Retry => continue,  // 竞争中，重试
            Steal::Empty => {
                // victim 队列为空，检查下一个
                if all_threads_empty() {
                    return None;  // 没有任务可偷
                }
            }
        }
    }
}
```

---

### 4. 任务窃取的时机

```txt
┌─────────────────────────────────────────────────────────────────┐
│                   线程状态机                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────┐                                                    │
│  │  Idle   │  ←── 没有任务可做                                    │
│  └────┬────┘                                                    │
│       │                                                         │
│       │ 窃取任务                                                 │
│       ▼                                                         │
│  ┌─────────┐    执行完毕    ┌─────────┐                        │
│  │ Working │ ────────────► │  Idle   │                        │
│  │  (工作) │               │  (空闲) │                        │
│  └─────────┘               └─────────┘                        │
│                                                                 │
│  窃取触发条件：                                                  │
│  1. 本地队列为空                                                │
│  2. 等待锁或 I/O（Rayon 不等待，这些用 Tokio）                   │
│  3. 任务完成，准备取下一个任务                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### 5. Fork-Join 模型

Rayon 基于 **Fork-Join** 并行模型：

```txt
┌─────────────────────────────────────────────────────────────────┐
│                    Fork-Join 执行模型                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                         main()                                   │
│                            │                                    │
│                            ▼                                    │
│                  ┌─────────────────┐                            │
│                  │   fork()        │                            │
│                  │   (拆分任务)     │                            │
│                  └────────┬────────┘                            │
│                           │                                     │
│              ┌────────────┴────────────┐                        │
│              │                         │                        │
│              ▼                         ▼                        │
│      ┌─────────────┐           ┌─────────────┐                 │
│      │  task_1()   │           │  task_2()   │                 │
│      │  (并行执行)  │           │  (并行执行)  │                 │
│      └──────┬──────┘           └──────┬──────┘                 │
│             │                         │                         │
│             └────────────┬────────────┘                         │
│                          │                                      │
│                          ▼                                      │
│                  ┌─────────────────┐                            │
│                  │   join()        │                            │
│                  │   (等待合并)     │                            │
│                  └────────┬────────┘                            │
│                           │                                     │
│                           ▼                                     │
│                      result                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Rust 代码示例**：

```rust
// 这段代码会被编译成 fork-join 执行
let result = par_iter()
    .map(|x| expensive_computation(x))  // fork: 拆分任务
    .sum();                              // join: 合并结果
```

**内部转换**（伪代码）：

```rust
// Rayon 内部把并行迭代转换为 fork-join
fn parallel_sum(data: &[i32]) -> i32 {
    if data.len() <= THRESHOLD {
        data.iter().sum()
    } else {
        let mid = data.len() / 2;
        let left = spawn(|| parallel_sum(&data[..mid]));    // fork left
        let right = spawn(|| parallel_sum(&data[mid..]));   // fork right
        left.join() + right.join()                          // join
    }
}
```

---

### 6. 递归任务划分

```txt
┌─────────────────────────────────────────────────────────────────┐
│                    递归任务划分树                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                           root                                   │
│                            / \                                  │
│                           /   \                                 │
│                      left_1   right_1                           │
│                        / \       \                              │
│                       /   \       \                             │
│                  left_2  right_2  right_3                       │
│                    ...      ...      ...                        │
│                                                                 │
│  划分过程：                                                      │
│  1. root: 10000 元素                                            │
│  2. left_1 + right_1: 各 5000 元素                              │
│  3. left_2 + right_2: 各 2500 元素                              │
│  4. ... 直到元素数 <= 1024                                       │
│                                                                 │
│  最终叶子节点：                                                  │
│  - 每个叶子处理 1024 个元素                                      │
│  - 约 10 个叶子节点                                             │
│  - 可以被 10 个线程并行处理                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**代码实现原理**：

```rust
// 简化的 divide-and-conquer
fn recursive_process<T, F>(data: &[T], f: &F)
where
    F: Fn(&T),
{
    if data.len() <= MIN_LEN {
        // 叶子节点：直接处理
        for item in data {
            f(item);
        }
    } else {
        // 内部节点：拆分处理
        let mid = data.len() / 2;
        let (left, right) = data.split_at(mid);

        // spawn 两个子任务（Rayon 自动管理线程）
        rayon::scope(|s| {
            s.spawn(|_| recursive_process(left, f));
            s.spawn(|_| recursive_process(right, f));
        });
    }
}
```

---

### 7. 负载均衡

```txt
┌─────────────────────────────────────────────────────────────────┐
│                    负载均衡示例                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  初始状态：任务大小不均匀                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Thread 0: [██████████████████████████████] (大任务)     │   │
│  │  Thread 1: [██] (小任务)                                 │   │
│  │  Thread 2: [██] (小任务)                                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  窃取后：                                                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Thread 0: [████████████████]                           │   │
│  │  Thread 1: [████████]   ◄─── 从 Thread 0 偷来            │   │
│  │  Thread 2: [████████]   ◄─── 从 Thread 0 偷来            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  结果：所有线程工作量相近                                         │
│                                                                 │
│  负载均衡指标：                                                  │
│  - 理想：每个线程工作量相同                                      │
│  - 实际：通过窃取动态平衡                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**窃取决策**：

```rust
// 什么时候窃取？
fn try_steal() -> Option<Task> {
    // 1. 本地队列为空
    if self.local_deque.is_empty() {
        // 2. 尝试窃取
        for victim in all_threads() {
            if let Some(task) = victim.steal_half() {
                return Some(task);
            }
        }
    }
    None
}
```

---

### 8. 为什么 Rayon 高效？

```txt
传统线程池 vs Rayon：

传统线程池：
┌─────────────────────────────────────────────────────────────┐
│ Thread 1: [████████░░░░░░] 阻塞等待 I/O                      │
│ Thread 2: [░░░░░░░░░░░░░░░░░] 阻塞等待 I/O                   │
│ Thread 3: [░░░░░░░░░░░████] 阻塞等待 I/O                      │
│                                                              │
│ 问题：大量线程在等待，CPU 利用率低                              │
└─────────────────────────────────────────────────────────────┘

Rayon：
┌─────────────────────────────────────────────────────────────┐
│ Thread 1: [████████████████] 处理计算                        │
│ Thread 2: [██████████████]   处理计算                        │
│ Thread 3: [████████████]     处理计算                        │
│                                                              │
│ 优势：所有线程都在工作，CPU 利用率高                           │
│      工作窃取避免负载不均                                      │
└─────────────────────────────────────────────────────────────┘
```

**高效原因**：

```txt
| 特性 | 说明 | 收益 |
|------|------|------|
| 工作窃取 | 空闲线程从繁忙线程偷任务 | 自动负载均衡 |
| 无锁/少锁 | 每个线程操作自己的队列 | 减少锁竞争 |
| 任务粒度 | 自动拆分到合适大小 | 避免过度划分 |
| 栈复用 | 子任务在同一线程运行 | 减少内存分配 |
| 批量窃取 | 一次窃取多个任务 | 减少窃取次数 |
```

---

### 9. Tokio vs Rayon 详细对比

```txt
┌─────────────────────────────────────────────────────────────────────────┐
│                         Tokio vs Rayon 详细对比                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌────────────────────┬────────────────────────────────────────────────┐│
│  │       维度         │              Tokio              │    Rayon      ││
│  ├────────────────────┼────────────────────────────────────────────────┤│
│  │ 任务模型           │ 异步 I/O + 事件循环          │ Fork-Join      ││
│  │ 任务状态           │ Ready/Running/Pending        │ Working/Idle   ││
│  │ 任务切换           │ 非阻塞 + Waker 唤醒          │ 直接切换       ││
│  │ 任务数量           │ 百万级并发                   │ 千级并行       ││
│  │ 适用场景           │ I/O 密集型                   │ CPU 密集型     ││
│  │ 调度方式           │ 事件驱动                     │ 工作窃取       ││
│  │ 依赖关系           │ 支持任务依赖                 │ 任务独立       ││
│  │ 内存开销           │ 低（协程）                   │ 中（线程）     ││
│  │ 上下文切换         │ 用户态                       │ 内核态         ││
│  └────────────────────┴────────────────────────────────────────────────┘│
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐│
│  │                          配合使用                                     ││
│  ├─────────────────────────────────────────────────────────────────────┤│
│  │                                                                      ││
│  │   Tokio (I/O)                          Rayon (计算)                  ││
│  │       │                                    │                          ││
│  │       ▼                                    ▼                          ││
│  │   ┌──────────────────────────────────────────────────────┐          ││
│  │   │              应用程序                                 │          ││
│  │   │   例如：                                             │          ││
│  │   │   async {                                           │          ││
│  │   │       let data = network_request().await;  // Tokio  │          ││
│  let result = │   │       process(data).await;     // Tokio  │          ││
│  │   │       // 如果 process 是 CPU 密集型：                  │          ││
│  │   │       // tokio::task::spawn_blocking(|| heavy())     │          ││
│  │   │   }                                                  │          ││
│  │   └──────────────────────────────────────────────────────┘          ││
│  │                                                                      ││
│  └─────────────────────────────────────────────────────────────────────┘│
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 10. 一句话理解原理

```txt
Rayon = 把数据切成小块 + 让多个线程并行处理 + 空闲时偷别线程的任务
```

**核心公式**：

```txt
Fork (拆分) + Work-Stealing (调度) + Join (合并) = Rayon 并行
```

---

## 基本用法

### 1. 并行迭代器

```rust
// 顺序版
let sum: i32 = (0..1000).sum();

// 并行版
let sum: i32 = (0..1000).par_iter().sum();
```

### 2. map + collect

```rust
let nums = vec![1, 2, 3, 4];

// 顺序版
let doubled: Vec<_> = nums.iter().map(|x| x * 2).collect();

// 并行版
let doubled: Vec<_> = nums.par_iter().map(|x| x * 2).collect();
```

### 3. filter + collect

```rust
let nums = vec![1, 2, 3, 4, 5, 6];

// 只保留偶数
let evens: Vec<_> = nums.par_iter().filter(|x| **x % 2 == 0).cloned().collect();
```

### 4. partition_map（Monad 中常用）

```rust
use either::Either;

// 分类处理：成功 vs 失败
let (successes, failures): (Vec<_>, Vec<_>) = items
    .into_par_iter()
    .partition_map(|item| {
        if validate(item) {
            Either::Left(item)  // 成功
        } else {
            Either::Right(item) // 失败
        }
    });
```

---

## Monad 中的实际用法

### 1. 交易签名恢复

```rust
lib.rs (monad-eth-block-validator)

// 并行恢复签名
let recovered_txns: VecDeque<Recovered<TxEnvelope>> = transactions
    .into_par_iter()
    .map(|tx| {
        let signer = tx.secp256k1_recover()?;
        Ok(Recovered::new_unchecked(tx.clone(), signer))
    })
    .collect::<Result<_, monad_secp::Error>>()
```

### 2. 交易验证

```rust
mod.rs (monad-eth-txpool)

// 并行验证交易
let (txs, invalid_txs): (Vec<_>, Vec<_>) = txs
    .into_par_iter()
    .partition_map(|tx| {
        Either::from(ValidEthTransaction::validate(...)).flip()
    });
```

### 3. EIP-7702 授权处理

```rust
// 并行处理授权列表
let authorizations_7702: Vec<RecoveredAuthorization> = txn_7702
    .tx()
    .authorization_list
    .par_iter()
    .filter_map(|signed_auth| {
        signed_auth.recover_authority().ok().map(|authority| {
            RecoveredAuthorization::new_unchecked(
                signed_auth.inner().clone(),
                RecoveredAuthority::Valid(authority),
            )
        })
    })
    .collect();
```

---

## API 对比

```txt
| 顺序版 | 并行版 | 说明 |
|--------|--------|------|
| `.iter()` | `.par_iter()` | 不可变借用 |
| `.iter_mut()` | `.par_iter_mut()` | 可变借用 |
| `.into_iter()` | `.into_par_iter()` | 获取所有权 |
| `.map()` | `.map()` | 映射（保持并行） |
| `.filter()` | `.filter()` | 过滤 |
| `.sum()` | `.sum()` | 求和 |
| `.reduce()` | `.reduce()` | 自定义聚合 |
| `.collect()` | `.collect()` | 收集 |
```

---

## 进阶用法

### 1. 自定义聚合

```rust
let max = par_iter.fold(|| i32::MIN, |a, b| a.max(b))
                   .reduce(|| i32::MIN, |a, b| a.max(b));
```

### 2. 带索引的迭代

```rust
par_iter.enumerate().for_each(|(i, value)| {
    println!("Index {}: {}", i, value);
});
```

### 3. chunks 分块处理

```rust
par_iter.chunks(100).for_each(|chunk| {
    // 每块 100 个元素
});
```

---

## 性能注意事项

### 什么时候用 Rayon？

✅ **适合**：

- CPU 密集型任务（计算、密码学）
- 大数据集（几千个元素以上）
- 任务之间相互独立

❌ **不适合**：

- I/O 密集型任务（用 Tokio）
- 小数据集（开销不值得）
- 有依赖关系的任务

---

## 与 Tokio 的对比

```txt
┌─────────────────────────────────────────────────────────────┐
│                        运行时对比                            │
├─────────────────────────────────────────────────────────────┤
│  Tokio                     │  Rayon                         │
│  ────────────────────────  │  ────────────────────────────  │
│  异步 I/O 处理             │  CPU 并行计算                  │
│  事件循环驱动              │  工作窃取调度                  │
│  协程 (async/await)        │  并行迭代器                    │
│  处理网络/文件 I/O         │  处理大量数据                  │
└─────────────────────────────────────────────────────────────┘

在 Monad 中：
- Tokio: 网络通信、状态同步、IPC
- Rayon: 交易验证、签名恢复、区块验证
```

---

## 常见问题

### Q: 线程数设多少合适？

```rust
// 默认：CPU 核心数
let pool = RayonBuilder::new().build();

// 自定义：8 个线程
let pool = RayonBuilder::new().num_threads(8).build();
```

**建议**：

- CPU 密集型：线程数 = CPU 核心数
- I/O 混合：可以略多于核心数

### Q: 如何调试并行代码？

```rust
use tracing::trace_span;

// 添加追踪
par_iter().for_each(|item| {
    let _span = trace_span!("processing", ?item).entered();
    // 处理逻辑
});
```

### Q: panic 会怎样？

```rust
// 一个任务 panic，整个并行操作都会 panic
// 可以用 catch_unwind 捕获
```

## 学习资源

1. 官方文档：https://docs.rs/rayon/
2. Rayon 教程：https://github.com/rayon-rs/rayon
3. Monad 中的实际用法：参考 `monad-eth-block-validator/src/lib.rs`
4. 论文：https://people.csail.mit.edu/shanir/publications/

---

## 一句话总结

```txt
Rayon = 把 ".iter()" 改成 ".par_iter()" 就能并行
```

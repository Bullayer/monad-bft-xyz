éå¸¸å¥½ï¼Œè¿™ä¸ªé¡ºåº**å®Œå…¨æ­£ç¡®**ã€‚
å…ˆ**æŠ›å¼€ Tokio**ï¼Œåªä» **Rust æ ‡å‡†åº“è¯­ä¹‰**ç†è§£ï¼š

> async / await / Future / Stream
> ä¸ç„¶åé¢ä¸€åˆ‡è¿è¡Œæ—¶ï¼ˆTokioã€async-stdï¼‰éƒ½ä¼šå˜â€œç„å­¦â€ã€‚

æˆ‘æŒ‰ï¼š
**æ¦‚å¿µ â†’ çœŸå®è¯­ä¹‰ â†’ æœ€å°ä»£ç  â†’ å¿ƒæ™ºæ¨¡å‹ â†’ ç»ƒä¹ é¢˜**
ä¸€æ­¥æ­¥æ¥ã€‚

---

# ä¸€ã€å…ˆç«‹ä½ 4 ä¸ªåŸºæœ¬æ¦‚å¿µï¼ˆä¸€å¥è¯ç‰ˆï¼‰

> 1ï¸âƒ£ `async fn`ï¼š
> ğŸ‘‰ ä¸æ˜¯å‡½æ•°ï¼Œæ˜¯**è¿”å›ä¸€ä¸ª Future çš„å·¥å‚**ã€‚

> 2ï¸âƒ£ `Future`ï¼š
> ğŸ‘‰ ä¸€ä¸ª**å¯ä»¥è¢«åå¤ poll çš„çŠ¶æ€æœº**ã€‚

> 3ï¸âƒ£ `.await`ï¼š
> ğŸ‘‰ ä¸æ˜¯é˜»å¡ï¼Œæ˜¯ï¼š
> â€œå¦‚æœæ²¡å¥½å°± return Pendingï¼ŒæŠŠæ§åˆ¶æƒè®©å‡ºå»â€ã€‚

> 4ï¸âƒ£ `Stream`ï¼š
> ğŸ‘‰ Future çš„â€œå¤šæ¬¡ç‰ˆâ€ï¼Œ
> ğŸ‘‰ async ç‰ˆ Iteratorã€‚

---

# äºŒã€Future çš„çœŸå®å«ä¹‰ï¼ˆä¸æ˜¯â€œå°†æ¥ä¼šæœ‰ä¸ªå€¼â€ï¼‰

æ ‡å‡†åº“é‡Œï¼š

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context)
        -> Poll<Self::Output>;
}
```

ä½ å¿…é¡»æŠ“ä½è¿™ä¸€ç‚¹ï¼š

> **Future = ä¸€ä¸ªâ€œæ‰‹å†™çŠ¶æ€æœºâ€**
> poll ä¸€æ¬¡ï¼Œèµ°ä¸€æ­¥ã€‚
> Ready = å®Œæˆã€‚
> Pending = æ²¡å¥½ï¼Œä¸‹æ¬¡å†æ¥ã€‚

---

# ä¸‰ã€async fn åˆ°åº•è¿”å›äº†ä»€ä¹ˆï¼Ÿ

```rust
async fn foo() -> i32 {
    42
}

let fut = foo();
```

æ­¤æ—¶ï¼š

* `fut` çš„ç±»å‹æ˜¯ï¼š`impl Future<Output = i32>`
* **ä»€ä¹ˆéƒ½æ²¡å‘ç”Ÿ**
* æ²¡æ‰§è¡Œ
* æ²¡ç®— 42

ç›´åˆ°ä½ ï¼š

```rust
fut.await
```

æˆ–æœ‰äººå» poll å®ƒã€‚

---

# å››ã€.await çš„çœŸå®è¯­ä¹‰ï¼ˆæœ€å…³é”®ï¼‰

```rust
let x = bar().await;
```

ä¸æ˜¯â€œé˜»å¡ç­‰ bar å®Œæˆâ€ã€‚

è€Œæ˜¯**ç­‰ä»·è¯­ä¹‰**ï¼š

```rust
loop {
    match bar_fut.poll(cx) {
        Poll::Ready(x) => break x,
        Poll::Pending => return Poll::Pending,
    }
}
```

ä¹Ÿå°±æ˜¯è¯´ï¼š

* å½“å‰å‡½æ•°ï¼ˆFutureï¼‰æš‚åœ
* æŠŠæ§åˆ¶æƒäº¤è¿˜è°ƒåº¦å™¨
* ç­‰ waker æŠŠæˆ‘å”¤é†’
* ä¸‹æ¬¡ä» `.await` åç»§ç»­

---

# äº”ã€ä¸€ä¸ª async fn ä¼šè¢«ç¼–è¯‘æˆä»€ä¹ˆï¼Ÿ

```rust
async fn foo() -> i32 {
    let x = bar().await;
    x + 1
}
```

ç¼–è¯‘å™¨ä¼šå˜æˆç±»ä¼¼ï¼š

```rust
enum FooState {
    Start,
    WaitingOnBar(BarFuture),
    Done,
}

struct Foo {
    state: FooState,
}

impl Future for Foo {
    type Output = i32;

    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<i32> {
        match self.state {
            FooState::Start => {
                let bar_fut = bar();
                self.state = FooState::WaitingOnBar(bar_fut);
                return Poll::Pending;
            }

            FooState::WaitingOnBar(ref mut bar_fut) => {
                match bar_fut.poll(cx) {
                    Poll::Pending => Poll::Pending,
                    Poll::Ready(x) => {
                        self.state = FooState::Done;
                        Poll::Ready(x + 1)
                    }
                }
            }

            FooState::Done => panic!("polled after completion"),
        }
    }
}
```

**ç»“è®ºï¼š**

> `async fn` = è‡ªåŠ¨ç”ŸæˆçŠ¶æ€æœº + Future å®ç°ã€‚

---

# å…­ã€async â‰  å¹¶è¡Œ â‰  å¤šçº¿ç¨‹

è¿™ç‚¹ä½ å¿…é¡» 100% åƒé€ã€‚

```rust
async fn f() {
    heavy_cpu();        // âŒ æ²¡æœ‰ .await
    println!("done");
}
```

è¿™æ®µä»£ç ï¼š

* ä¸ä¼šè®©å‡º CPU
* ä¸ä¼šæš‚åœ
* ä¼šä¸€å£æ°”è·‘å®Œ

ä¹Ÿå°±æ˜¯è¯´ï¼š

> async æ˜¯**åä½œå¼**ï¼Œ
> æ²¡æœ‰æŠ¢å ã€‚

---

# ä¸ƒã€æ ‡å‡†åº“é‡Œå…¶å®æ²¡æœ‰â€œæ‰§è¡Œå™¨â€

è¿™ä¸€ç‚¹å¾ˆåç›´è§‰ã€‚

Rust æ ‡å‡†åº“ï¼š

* å®šä¹‰äº†ï¼š

  * `Future`
  * `Poll`
  * `Context`
  * `Waker`
* **æ²¡æœ‰**ï¼š

  * çº¿ç¨‹æ± 
  * è°ƒåº¦å™¨
  * äº‹ä»¶å¾ªç¯
  * runtime

ä¹Ÿå°±æ˜¯è¯´ï¼š

> æ ‡å‡†åº“åªç»™ä½ â€œåè®®â€ï¼Œ
> Tokio / async-std æ‰ç»™ä½ â€œå‘åŠ¨æœºâ€ã€‚

---

# å…«ã€æ‰‹å†™ä¸€ä¸ªæœ€å° Futureï¼ˆçœ¼è§ä¸ºå®ï¼‰

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

struct CountToThree {
    n: u32,
}

impl Future for CountToThree {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context)
        -> Poll<()> 
    {
        if self.n < 3 {
            self.n += 1;
            println!("poll: {}", self.n);
            Poll::Pending
        } else {
            println!("done");
            Poll::Ready(())
        }
    }
}
```

å¦‚æœä½ æœ‰ä¸€ä¸ªæœ€ç®€ executorï¼š

```rust
fn block_on<F: Future>(mut fut: F) {
    use std::task::{RawWaker, RawWakerVTable, Waker};

    fn dummy_raw_waker() -> RawWaker {
        fn no_op(_: *const ()) {}
        fn clone(_: *const ()) -> RawWaker { dummy_raw_waker() }
        let vtable = &RawWakerVTable::new(clone, no_op, no_op, no_op);
        RawWaker::new(std::ptr::null(), vtable)
    }

    let waker = unsafe { Waker::from_raw(dummy_raw_waker()) };
    let mut cx = Context::from_waker(&waker);

    let mut fut = unsafe { Pin::new_unchecked(&mut fut) };

    loop {
        match fut.as_mut().poll(&mut cx) {
            Poll::Ready(()) => break,
            Poll::Pending => {}
        }
    }
}
```

è·‘ï¼š

```rust
fn main() {
    block_on(CountToThree { n: 0 });
}
```

è¾“å‡ºï¼š

```
poll: 1
poll: 2
poll: 3
done
```

è¿™ä¸€æ­¥éå¸¸é‡è¦ï¼š

> ä½ ç°åœ¨å·²ç»äº²çœ¼çœ‹åˆ°ï¼š
> Future = è¢«åå¤ poll çš„çŠ¶æ€æœºã€‚

---

# ä¹ã€Stream æ˜¯ä»€ä¹ˆï¼Ÿï¼ˆæ ‡å‡†åº“é‡Œè¿˜æ²¡ stabilizedï¼‰

æ ‡å‡†åº“**æš‚æ—¶æ²¡æœ‰** `Stream` traitï¼ˆåœ¨ `futures-core` é‡Œï¼‰ã€‚

æ¦‚å¿µå¯¹é½ Futureï¼š

```rust
trait Stream {
    type Item;
    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context
    ) -> Poll<Option<Self::Item>>;
}
```

* `Poll::Ready(Some(x))` â†’ äº§å‡ºä¸€ä¸ªå€¼
* `Poll::Pending` â†’ ç°åœ¨æ²¡å€¼
* `Poll::Ready(None)` â†’ ç»“æŸ

---

# åã€æ‰‹å†™ä¸€ä¸ªæœ€å° Stream

```rust
struct Counter {
    cur: u32,
    max: u32,
}

impl Stream for Counter {
    type Item = u32;

    fn poll_next(
        mut self: Pin<&mut Self>,
        _cx: &mut Context,
    ) -> Poll<Option<u32>> 
    {
        if self.cur < self.max {
            let val = self.cur;
            self.cur += 1;
            Poll::Ready(Some(val))
        } else {
            Poll::Ready(None)
        }
    }
}
```

è¿™å’Œä½ åˆšåˆšå†™çš„ Future å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œåªæ˜¯â€œå¤šæ¬¡ Readyâ€ã€‚

---

# åä¸€ã€ä¸€ä¸ªéå¸¸é‡è¦çš„å¿ƒæ™ºæ¨¡å‹

> async fn = çŠ¶æ€æœºæ„é€ å™¨
> Future = çŠ¶æ€æœºå®ä¾‹
> .await = çŠ¶æ€æœº yield ç‚¹
> Executor = poll è¿™äº›çŠ¶æ€æœºçš„äºº
> Stream = ä¼šå¤šæ¬¡ yield çš„ Future

---

# åäºŒã€ä½ ç°åœ¨å°±èƒ½åšçš„ 6 ä¸ªåŸºç¡€ç»ƒä¹ é¢˜ï¼ˆéå¸¸æ¨èï¼‰

è¿™äº›ç»ƒå®Œï¼Œä½ å¯¹ async è¯­ä¹‰ä¼šâ€œè‚Œè‚‰è®°å¿†â€ã€‚

---

## ç»ƒä¹  1ï¼šçœ‹è¾“å‡ºé¡ºåºï¼ˆæ ¸å¿ƒé¢˜ï¼‰

```rust
async fn foo() -> i32 {
    println!("foo start");
    let x = bar().await;
    println!("foo got {}", x);
    x + 1
}

async fn bar() -> i32 {
    println!("bar start");
    10
}

fn main() {
    let fut = foo();
    // å‡è®¾ç”¨ block_on è·‘å®ƒ
}
```

**é—®é¢˜ï¼š**

1. å“ªäº› println ä»€ä¹ˆæ—¶å€™æ‰§è¡Œï¼Ÿ
2. å“ªäº›æ˜¯åœ¨ `.await` ä¹‹å‰ï¼Ÿå“ªäº›ä¹‹åï¼Ÿ

---

## ç»ƒä¹  2ï¼šawait æ˜¯ä¸æ˜¯â€œè®©å‡ºâ€ï¼Ÿ

```rust
async fn f() {
    println!("A");
    g().await;
    println!("B");
}

async fn g() {
    println!("C");
}
```

**é—®é¢˜ï¼š**

è¾“å‡ºé¡ºåºæ˜¯ä»€ä¹ˆï¼Ÿ
ä¸ºä»€ä¹ˆä¸æ˜¯ A B Cï¼Ÿ

---

## ç»ƒä¹  3ï¼šå¿˜äº† await ä¼šæ€æ ·ï¼Ÿ

```rust
async fn foo() -> i32 {
    42
}

fn main() {
    let x = foo();
    println!("{:?}", x);
}
```

**é—®é¢˜ï¼š**

1. èƒ½ä¸èƒ½ç¼–è¯‘ï¼Ÿ
2. x æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿ
3. ä¼šä¸ä¼šæ‰“å° 42ï¼Ÿ

---

## ç»ƒä¹  4ï¼šæ‰‹å†™çŠ¶æ€æœº

æŠŠè¿™ä¸ªï¼š

```rust
async fn add_one() -> i32 {
    let x = async { 1 }.await;
    x + 1
}
```

**æ‰‹å†™æˆä¸€ä¸ª enum + impl Future**ã€‚

---

## ç»ƒä¹  5ï¼šFuture ä¼šä¸ä¼šè‡ªå·±è·‘ï¼Ÿ

```rust
async fn f() {
    println!("hi");
}

fn main() {
    let fut = f();
}
```

**é—®é¢˜ï¼š**

ä¼šä¸ä¼šæ‰“å° hiï¼Ÿ
ä¸ºä»€ä¹ˆï¼Ÿ

---

## ç»ƒä¹  6ï¼šStream vs Iterator

å¦‚æœä½ æœ‰ï¼š

```rust
let mut s = my_stream();
while let Some(x) = s.next().await {
    println!("{x}");
}
```

**é—®é¢˜ï¼š**

1. `.next().await` èƒŒåç­‰ä»·äºä»€ä¹ˆ poll é€»è¾‘ï¼Ÿ
2. å’Œ Iterator::next() æœ€å¤§è¯­ä¹‰å·®å¼‚æ˜¯ä»€ä¹ˆï¼Ÿ

---

# åä¸‰ã€ä½ ç°åœ¨è¿™ä¸€æ­¥éå¸¸å¯¹å‘³

ä½ ç°åœ¨åœ¨åšçš„è¿™æ­¥ï¼š

> å…ˆæ ‡å‡†åº“
> å† Tokio
> å†è°ƒåº¦å™¨
> å†é«˜æ€§èƒ½ç³»ç»Ÿ

è¿™æ˜¯**æ­£ç¡®è·¯çº¿**ã€‚

---

# å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥ç»§ç»­â€œè¡¥æœ€åä¸€å—åœ°åŸºâ€ï¼š

**1ï¸âƒ£ Pin / Unpin åˆ°åº•æ˜¯å¹²ä»€ä¹ˆçš„ï¼Ÿ**
ï¼ˆä¸ºä»€ä¹ˆ poll è¦ `Pin<&mut Self>`ï¼Ÿï¼‰

**2ï¸âƒ£ Waker / Context çš„çœŸå®èŒè´£**
ï¼ˆè°å”¤é†’è°ï¼Ÿæ€ä¹ˆæ³¨å†Œï¼Ÿï¼‰

è¿™ä¸¤å—ä¸€åƒé€ï¼Œä½ å¯¹ async çš„ç†è§£å°±ä¼šä»
â€œä¼šç”¨â€ â†’ â€œèƒ½å†™ runtimeâ€ã€‚

---------------------------------------------

éå¸¸å¥½ï¼Œç°åœ¨è¿™ä¸€æ­¥æ˜¯**æŠŠâ€œæ ‡å‡†åº“è¯­ä¹‰â€çœŸæ­£è½åˆ°åœ°ä¸Š**ã€‚
ä½ åˆšåˆšå·²ç»åƒé€äº†ï¼š

> Future = çŠ¶æ€æœº
> .await = yield
> æ ‡å‡†åº“æ²¡æœ‰ executor

ç°åœ¨æˆ‘ä»¬**åªåŠ  Tokio è¿™ä¸€å±‚å‘åŠ¨æœº**ï¼ŒæŠŠä¸€åˆ‡è¿èµ·æ¥ã€‚

æˆ‘æŒ‰ï¼š
**Tokio åœ¨è¡¥ä»€ä¹ˆ â†’ çœŸå®æ‰§è¡Œè·¯å¾„ â†’ .await åœ¨ Tokio é‡Œå‘ç”Ÿäº†ä»€ä¹ˆ â†’ ä½ ä¼šè¸©çš„å‘ â†’ å¯¹é½ä½ å…³å¿ƒçš„ç³»ç»Ÿè®¾è®¡**
æ¥è§£ã€‚

---

# ä¸€ã€Tokio åˆ°åº•è¡¥äº†å“ª 3 æ ·ä¸œè¥¿ï¼Ÿ

æ ‡å‡†åº“åªæœ‰â€œåè®®â€ï¼ŒTokio è¡¥çš„æ˜¯ï¼š

```
1) Executorï¼ˆè°ƒåº¦å™¨ï¼‰
2) Reactorï¼ˆepoll/kqueueï¼‰
3) ä»»åŠ¡ç³»ç»Ÿï¼ˆspawn / waker / é˜Ÿåˆ—ï¼‰
```

ä¸€å¥è¯ï¼š

> Tokio =
> â€œpoll Future çš„äººâ€ + â€œç­‰ IO çš„äººâ€ + â€œå”¤é†’ Future çš„äººâ€ã€‚

---

# äºŒã€ä» main å¼€å§‹ï¼šTokio Runtime åœ¨å¹²ä»€ä¹ˆï¼Ÿ

```rust
#[tokio::main]
async fn main() {
    foo().await;
}
```

å®å±•å¼€åæœ¬è´¨æ˜¯ï¼š

```rust
fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        foo().await;
    });
}
```

ä¹Ÿå°±æ˜¯è¯´ï¼š

> Tokio å…ˆå»ºä¸€ä¸ª runtimeï¼Œ
> ç„¶åç”¨ block_on å¼€å§‹ poll ä½ çš„ main Futureã€‚

---

# ä¸‰ã€ä¸€æ¡ Future åœ¨ Tokio é‡Œå®Œæ•´è·‘ä¸€åœˆ

æˆ‘ä»¬ç”¨è¿™æ®µæœ€å°çœŸå®ä»£ç ï¼š

```rust
#[tokio::main]
async fn main() {
    let x = foo().await;
    println!("result = {}", x);
}

async fn foo() -> i32 {
    println!("foo start");
    let y = bar().await;
    println!("foo got {}", y);
    y + 1
}

async fn bar() -> i32 {
    println!("bar start");
    10
}
```

---

## Step 1ï¼šspawn main Future

```text
Tokio Runtime
  â†’ æŠŠ main() çš„ async block åŒ…æˆ Task
  â†’ push åˆ° worker çš„ run queue
```

---

## Step 2ï¼šWorker çº¿ç¨‹å¼€å§‹ poll

```text
worker_loop:
  pop task
  poll(task.future)
```

è¿›å…¥ï¼š

```text
poll(main future)
  â†’ è¿›å…¥ foo().await
```

---

## Step 3ï¼špoll foo()

```text
poll(foo future)
  â†’ println!("foo start")
  â†’ é‡åˆ° bar().await
```

---

## Step 4ï¼špoll bar()

```text
poll(bar future)
  â†’ println!("bar start")
  â†’ ç«‹åˆ»è¿”å› Poll::Ready(10)
```

---

## Step 5ï¼šæ¢å¤ foo()

```text
bar().await å¾—åˆ° 10
â†’ println!("foo got 10")
â†’ foo è¿”å› Poll::Ready(11)
```

---

## Step 6ï¼šæ¢å¤ main()

```text
foo().await å¾—åˆ° 11
â†’ println!("result = 11")
â†’ main è¿”å› Poll::Ready(())
```

---

**æ³¨æ„ï¼š**

> æ•´ä¸ªè¿‡ç¨‹
> æ²¡æœ‰çº¿ç¨‹åˆ‡æ¢
> æ²¡æœ‰ IO
> æ²¡æœ‰ Pending
> åªæ˜¯ä¸€å£æ°” poll å®Œã€‚

---

# å››ã€çœŸæ­£æœ‰ IO æ—¶ï¼š.await åœ¨ Tokio é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ

ç°åœ¨æ¢æˆçœŸå® IOï¼š

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

async fn handle(mut s: TcpStream) {
    let mut buf = [0; 1024];
    let n = s.read(&mut buf).await;
    s.write_all(&buf[..n]).await;
}
```

---

## Step 1ï¼šç¬¬ä¸€æ¬¡ poll åˆ° read().await

```text
poll(handle future)
  â†’ è¿›å…¥ s.read().await
  â†’ è°ƒç”¨ TcpStream çš„ poll_read()
```

---

## Step 2ï¼šsocket ç°åœ¨æ²¡æ•°æ®

```text
poll_read()
  â†’ æ³¨å†Œ waker åˆ° Reactor
  â†’ return Poll::Pending
```

è¿™ä¸€æ­¥éå¸¸å…³é”®ï¼š

> Future ä¸å†å¾€ä¸‹èµ°
> ä»»åŠ¡æš‚åœ
> Tokio çº¿ç¨‹ç«‹åˆ»å»è·‘åˆ«çš„ä»»åŠ¡ã€‚

---

## Step 3ï¼šReactor åœ¨å¹²ä»€ä¹ˆï¼Ÿ

Tokio å†…éƒ¨ Reactor çº¿ç¨‹ï¼š

```text
epoll_wait()
  â†’ fd å¯è¯»
  â†’ æ‰¾åˆ°å¯¹åº” waker
  â†’ waker.wake()
```

---

## Step 4ï¼šwaker.wake()

```text
wake()
  â†’ æŠŠ handle task push å›æŸä¸ª worker çš„ run queue
```

---

## Step 5ï¼šä»»åŠ¡è¢«å†æ¬¡ poll

```text
worker pop handle task
  â†’ poll(handle future)
  â†’ ä» s.read().await åç»§ç»­
```

---

## Step 6ï¼šç»§ç»­å¾€ä¸‹æ‰§è¡Œ

```text
å¾—åˆ° n
â†’ s.write_all(...).await
â†’ å¯èƒ½å†æ¬¡ Pending
â†’ é‡å¤ä¸Šé¢çš„æµç¨‹
```

---

# äº”ã€ä½ ç°åœ¨å¯ä»¥ç²¾ç¡®ç†è§£è¿™å¥è¯äº†

> `.await` ä¸æ˜¯é˜»å¡çº¿ç¨‹
> è€Œæ˜¯ï¼š
> â€œå¦‚æœæ²¡å‡†å¤‡å¥½ï¼Œå°± return Pendingï¼Œ
> æŠŠæˆ‘æŒ‚èµ·ï¼Œç­‰ waker å† poll æˆ‘â€ã€‚

---

# å…­ã€Tokio è°ƒåº¦å™¨åœ¨å¹²ä»€ä¹ˆï¼Ÿï¼ˆå¯¹é½ä½ åˆšåˆšæ‡‚çš„ï¼‰

Tokio çš„ worker çº¿ç¨‹æœ¬è´¨ï¼š

```text
loop {
    task = pop_local_queue() or steal()
    poll(task.future)
}
```

ä½ ç°åœ¨å·²ç»éå¸¸ç†Ÿè¿™ä¸ªæ¨¡å‹äº†ï¼š

| ä½ åˆšå­¦çš„           | Tokio          |
| -------------- | -------------- |
| æ‰‹å†™ block_on    | Tokio executor |
| poll(Future)   | Worker çº¿ç¨‹      |
| return Pending | ä»»åŠ¡è®©å‡º CPU       |
| waker.wake()   | ä»»åŠ¡é‡æ–°å…¥é˜Ÿ         |

---

# ä¸ƒã€spawn / join åœ¨ Tokio é‡Œåˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿ

---

## 7.1 tokio::spawn

```rust
let h = tokio::spawn(async {
    foo().await
});
```

æœ¬è´¨ï¼š

```text
spawn(fut)
  â†’ Task { future, state }
  â†’ push åˆ° run queue
```

å®ƒ**ä¸ä¼šç«‹åˆ»æ‰§è¡Œ**ï¼Œåªæ˜¯ï¼š

> æŠŠ Future ä¸¢ç»™è°ƒåº¦å™¨ã€‚

---

## 7.2 ç­‰å¾…å­ä»»åŠ¡ï¼šJoinHandle

```rust
let x = h.await?;
```

è¯­ä¹‰ä¸Šç­‰ä»·äºï¼š

```text
loop {
    if child task done {
        return result
    } else {
        register waker
        return Pending
    }
}
```

---

# å…«ã€å¹¶å‘ vs ä¸²è¡Œ awaitï¼ˆä½ ç°åœ¨èƒ½ç²¾ç¡®è§£é‡Šäº†ï¼‰

---

## ä¸²è¡Œï¼š

```rust
let a = foo().await;
let b = bar().await;
```

æ—¶é—´ï¼š

```
foo å®Œ â†’ å† bar
```

---

## å¹¶å‘ï¼š

```rust
let (a, b) = tokio::join!(foo(), bar());
```

æˆ–ï¼š

```rust
let a = tokio::spawn(foo());
let b = tokio::spawn(bar());

let a = a.await?;
let b = b.await?;
```

è¯­ä¹‰ï¼š

```text
spawn foo â†’ å…¥é˜Ÿ
spawn bar â†’ å…¥é˜Ÿ

worker è½®æµ poll ä¸¤ä¸ª task
è° Pending è°è®©å‡º
```

---

# ä¹ã€ä½ ä¸€å®šä¼šè¸©çš„ 4 ä¸ª Tokio çº§å‘ï¼ˆä¸æ˜¯æ ‡å‡†åº“çº§ï¼‰

è¿™ 4 ä¸ªå‘æ­£å¥½å¯¹é½ä½ åœ¨æŠ çš„ gateway / é«˜æ€§èƒ½é“¾ã€‚

---

## 1ï¸âƒ£ åœ¨ async é‡Œåšé˜»å¡

```rust
std::thread::sleep(1);   // âŒ
tokio::time::sleep(1).await; // âœ…
```

å¦åˆ™ï¼š

> å¡æ­»æ•´ä¸ª worker çº¿ç¨‹ã€‚

---

## 2ï¸âƒ£ åœ¨ async é‡Œè·‘ CPU é‡æ´»

```rust
heavy(); // âŒ
tokio::spawn_blocking(|| heavy()); // âœ…
```

å¦åˆ™ï¼š

> å…¶ä»–ä»»åŠ¡å…¨éƒ¨é¥¿æ­»ã€‚

---

## 3ï¸âƒ£ ä¸€ä¸ª task è·‘å¤ªä¹…ä¸ .await

```rust
loop {
    do_cpu_work(); // âŒ æ²¡æœ‰ yield
}
```

å¦åˆ™ï¼š

> Tokio æ— æ³•æŠ¢å ä½ ã€‚

---

## 4ï¸âƒ£ å¿˜äº† .await = ä»»åŠ¡æ²¡è·‘

```rust
foo();        // âŒ
foo().await;  // âœ…
```

---

# åã€æŠŠ Tokio ç²¾ç¡®å¯¹é½ä½ å‰é¢ç†Ÿçš„æ¨¡å‹

ä½ å‰é¢å·²ç»å¾ˆç†Ÿï¼š

| ä½ ç†Ÿçš„                 | Tokio å¯¹åº”        |
| ------------------- | --------------- |
| Netty EventLoop     | Tokio worker    |
| epoll               | Reactor         |
| handler å›è°ƒ          | Future::poll    |
| fireChannelRead     | waker.wake      |
| Pipeline            | async è°ƒç”¨é“¾       |
| Rayon work-stealing | Tokio scheduler |

---

# åä¸€ã€ä½ ç°åœ¨åº”è¯¥æœ‰çš„â€œå®Œæ•´å¿ƒæ™ºæ¨¡å‹â€

> async fn = çŠ¶æ€æœºæ„é€ å™¨
> Future = çŠ¶æ€æœºå®ä¾‹
> .await = yield ç‚¹
> Tokio = poll çŠ¶æ€æœºçš„äºº
> Reactor = ç­‰ IO çš„äºº
> Waker = é‡æ–°æ’é˜Ÿçš„é’©å­

---

# åäºŒã€ç»™ä½  4 ä¸ª Tokio çº§å°ç»ƒä¹ ï¼ˆéå¸¸æ¨èï¼‰

è¿™ 4 é¢˜ä¸€åšï¼Œä½ ä¼šâ€œå½»åº•ä¸è¿·ç³Šâ€ã€‚

---

## ç»ƒä¹  1ï¼šè¾“å‡ºé¡ºåºï¼ˆTokio ç‰ˆï¼‰

```rust
#[tokio::main]
async fn main() {
    println!("A");
    tokio::spawn(async {
        println!("B");
    });
    println!("C");
}
```

**é—®é¢˜ï¼š**

1. è¾“å‡ºé¡ºåºå¯èƒ½æ˜¯ä»€ä¹ˆï¼Ÿ
2. ä¸ºä»€ä¹ˆä¸æ˜¯å›ºå®šé¡ºåºï¼Ÿ

---

## ç»ƒä¹  2ï¼šå¹¶å‘ vs ä¸²è¡Œ

```rust
async fn f() {
    tokio::time::sleep(Duration::from_secs(1)).await;
}

#[tokio::main]
async fn main() {
    f().await;
    f().await;
}
```

vs

```rust
#[tokio::main]
async fn main() {
    tokio::join!(f(), f());
}
```

**é—®é¢˜ï¼š**

1. ä¸¤æ®µä»£ç å„è€—æ—¶å¤šä¹…ï¼Ÿ
2. ä¸ºä»€ä¹ˆï¼Ÿ

---

## ç»ƒä¹  3ï¼šspawn vs ä¸ spawn

```rust
async fn f() {
    println!("hi");
}

#[tokio::main]
async fn main() {
    let h = tokio::spawn(f());
    println!("bye");
    h.await.unwrap();
}
```

**é—®é¢˜ï¼š**

1. hi å’Œ bye è°å…ˆæ‰“å°ï¼Ÿ
2. ä¸ºä»€ä¹ˆä¸ç¡®å®šï¼Ÿ

---

## ç»ƒä¹  4ï¼šé˜»å¡ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ

```rust
#[tokio::main]
async fn main() {
    tokio::spawn(async {
        loop {
            println!("tick");
            std::thread::sleep(Duration::from_secs(1)); // âŒ
        }
    });

    tokio::spawn(async {
        loop {
            println!("tock");
            tokio::time::sleep(Duration::from_secs(1)).await;
        }
    });
}
```

**é—®é¢˜ï¼š**

1. ä½ ä¼šçœ‹åˆ° tick / tock éƒ½æ­£å¸¸å—ï¼Ÿ
2. ä¸ºä»€ä¹ˆï¼Ÿ

---

# åä¸‰ã€ä½ ç°åœ¨è¿™ä¸€æ­¥éå¸¸å¯¹å‘³ï¼ˆè€Œä¸”å¾ˆé«˜çº§ï¼‰

ä½ ç°åœ¨çš„è·¯çº¿æ˜¯ï¼š

```
æ ‡å‡†åº“è¯­ä¹‰
   â†“
Tokio runtime
   â†“
è°ƒåº¦å™¨ / Reactor
   â†“
é«˜æ€§èƒ½ç³»ç»Ÿè®¾è®¡
```

è¿™æ­£æ˜¯ï¼š

> ä»â€œä¼šç”¨ asyncâ€
> åˆ°â€œèƒ½è®¾è®¡ async runtimeâ€ã€‚

---

# å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥ç»§ç»­æŠ ä¸€å±‚ä½ ä¸€å®šä¼šå–œæ¬¢çš„ï¼š

**1ï¸âƒ£ Tokio çš„è°ƒåº¦å™¨æºç çº§ç»“æ„ï¼ˆworker / run queue / stealï¼‰**
ï¼ˆå’Œ Rayon é€è¡Œå¯¹é½ï¼‰

**2ï¸âƒ£ ä¸€æ¡çœŸå® Tokio IO è¯·æ±‚è·¯å¾„**
ä» epoll â†’ waker â†’ Future â†’ .await æ¢å¤

è¿™ä¸¤æ¡ï¼Œç›´æ¥å¯¹é½ä½ ç°åœ¨åœ¨æŠ çš„ Hyper / gateway / é«˜æ€§èƒ½é“¾å¹¶å‘æ¨¡å‹ã€‚


-----------------------------------------------------
å¾ˆå¥½ï¼Œè¿™ä¸€å±‚**æ­£å¥½å¯¹é½ä½ å‰é¢æŠ  Rayon / Monad / Netty çš„è°ƒåº¦å™¨ç›´è§‰**ã€‚
æˆ‘æŒ‰**æºç çº§ç»“æ„ + æ‰§è¡Œè·¯å¾„ + å’Œ Rayon çš„é€ç‚¹å¯¹é½**ç»™ä½ æ‹†ã€‚

> ç›®æ ‡ï¼š
> ä½ çœ‹å®Œåï¼Œèƒ½åœ¨è„‘å­é‡Œâ€œå•æ­¥è·‘â€ Tokio worker çš„ while å¾ªç¯ã€‚

---

# ä¸€ã€Tokio è°ƒåº¦å™¨çš„ä¸‰ç§æ¨¡å¼ï¼ˆå…ˆå®šèŒƒå›´ï¼‰

Tokio runtime æœ‰ 3 ç§ schedulerï¼š

1. `current_thread`ï¼ˆå•çº¿ç¨‹ï¼‰
2. `multi_thread`ï¼ˆé»˜è®¤ï¼Œå¤š worker + work-stealingï¼‰
3. `multi_thread_alt`ï¼ˆè€å®ç°ï¼ŒåŸºæœ¬æ·˜æ±°ï¼‰

ä½ å…³å¿ƒçš„ä¸€å®šæ˜¯ **multi_thread**ã€‚

æºç å…¥å£ï¼ˆtokio 1.xï¼‰ï¼š

```
tokio/src/runtime/
  â”œâ”€â”€ scheduler/
  â”‚     â”œâ”€â”€ multi_thread/
  â”‚     â”‚     â”œâ”€â”€ worker.rs
  â”‚     â”‚     â”œâ”€â”€ queue.rs
  â”‚     â”‚     â”œâ”€â”€ park.rs
  â”‚     â”‚     â”œâ”€â”€ handle.rs
  â”‚     â”‚     â””â”€â”€ mod.rs
  â”‚     â””â”€â”€ current_thread/
```

---

# äºŒã€æ ¸å¿ƒç»“æ„ä½“ï¼ˆæœ€é‡è¦çš„ 4 ä¸ªï¼‰

ä½ åªè¦æŠ“ä½è¿™ 4 ä¸ªå°±è¡Œäº†ï¼š

---

## 1ï¸âƒ£ Worker

```rust
struct Worker {
    run_queue: LocalQueue<Task>,
    steal: StealQueue<Task>,
    parker: Parker,
    core: Core,
}
```

è¯­ä¹‰ï¼š

| å­—æ®µ        | å¹²å˜›çš„       |
| --------- | --------- |
| run_queue | æœ¬çº¿ç¨‹çš„æœ¬åœ°é˜Ÿåˆ—  |
| steal     | ç»™åˆ«äººå·çš„é˜Ÿåˆ—   |
| parker    | æ²¡ä»»åŠ¡æ—¶ park |
| core      | å½“å‰çº¿ç¨‹çš„è°ƒåº¦çŠ¶æ€ |

---

## 2ï¸âƒ£ LocalQueue / StealQueue

```rust
struct LocalQueue<T> {
    inner: queue::Local<T>
}

struct StealQueue<T> {
    inner: queue::Steal<T>
}
```

è¿™æ˜¯ä¸€ä¸ª **Chase-Lev åŒç«¯é˜Ÿåˆ—**ï¼ˆå’Œ Rayon åŒç±»ï¼‰ï¼š

* è‡ªå·± `push/pop` èµ°ä¸€ç«¯ï¼ˆå¿«ã€æ— é”ï¼‰
* åˆ«äºº `steal` èµ°å¦ä¸€ç«¯ï¼ˆæ…¢ã€åŸå­ï¼‰

---

## 3ï¸âƒ£ Task

```rust
struct Task {
    header: Header,
    future: UnsafeCell<Option<Future>>,
}
```

Header é‡Œæœ‰ï¼š

```rust
struct Header {
    state: AtomicUsize,
    vtable: &'static TaskVTable,
    scheduler: *const (),
}
```

é‡ç‚¹ï¼š

> æ¯ä¸ª spawn å‡ºæ¥çš„ Future
> éƒ½è¢«åŒ…æˆä¸€ä¸ª Task
> å¸¦åŸå­çŠ¶æ€æœºã€‚

---

## 4ï¸âƒ£ Scheduler / Handle

```rust
struct MultiThread {
    workers: Vec<Worker>,
    injector: Injector<Task>,
}
```

| å­—æ®µ       | å¹²å˜›çš„                |
| -------- | ------------------ |
| workers  | æ‰€æœ‰ worker çº¿ç¨‹       |
| injector | å…¨å±€æ³¨å…¥é˜Ÿåˆ—ï¼ˆè·¨çº¿ç¨‹ push ç”¨ï¼‰ |

---

# ä¸‰ã€Worker ä¸»å¾ªç¯ï¼ˆè¿™æ˜¯ Tokio çš„â€œå¿ƒè·³â€ï¼‰

ä½ å¯ä»¥æŠŠå®ƒæƒ³æˆï¼š

```rust
fn worker_loop(worker: &mut Worker) {
    loop {
        if let Some(task) = worker.run_queue.pop() {
            poll_task(task);
            continue;
        }

        if let Some(task) = scheduler.injector.pop() {
            worker.run_queue.push(task);
            continue;
        }

        if let Some(task) = steal_from_other_worker(worker) {
            worker.run_queue.push(task);
            continue;
        }

        // æ²¡æ´»äº†ï¼Œpark ç­‰ waker
        worker.parker.park();
    }
}
```

çœŸå®ä»£ç åœ¨ï¼š

```
tokio/src/runtime/scheduler/multi_thread/worker.rs
```

é€»è¾‘ä¸€æ¨¡ä¸€æ ·ï¼Œåªæ˜¯å¤šäº†ï¼š

* batch steal
* fairness
* cooperative budget

---

# å››ã€spawn ä¸€æ¡ä»»åŠ¡ï¼šæºç çº§è·¯å¾„

ä½ ç°åœ¨å…³å¿ƒçš„ä¸€å®šæ˜¯ï¼š

> `tokio::spawn(fut)`
> ç©¶ç«ŸæŠŠä»»åŠ¡å¡åˆ°å“ªäº†ï¼Ÿ

---

## Step 1ï¼šæ„é€  Task

```rust
let task = Task::new(future);
```

---

## Step 2ï¼šæäº¤ç»™è°ƒåº¦å™¨

```rust
handle.spawn(task);
```

åœ¨ `handle.rs` é‡Œï¼š

```rust
fn spawn(&self, task: Task) {
    if self.is_local_thread() {
        self.worker.run_queue.push(task);
    } else {
        self.injector.push(task);
        self.notify_one_worker();
    }
}
```

---

## Step 3ï¼šæŸä¸ª worker æ‹¿åˆ° task

```text
worker loop
  â†’ pop_local()
  â†’ pop_injector()
  â†’ steal()
```

---

# äº”ã€poll ä¸€æ¡ä»»åŠ¡ï¼šTask::poll è·¯å¾„

è¿™æ˜¯ Tokio å’Œä½ åˆšå­¦çš„ Future åè®®å¯¹é½çš„åœ°æ–¹ã€‚

---

## Step 1ï¼šworker å–åˆ° task

```rust
let task = worker.run_queue.pop().unwrap();
```

---

## Step 2ï¼šè¿›å…¥ Task::poll

```rust
task.poll(&mut cx);
```

ç®€åŒ–åï¼š

```rust
fn poll(task: &Task, cx: &mut Context) {
    if !task.transition_to_running() {
        return;
    }

    match task.future.poll(cx) {
        Poll::Ready(_) => task.complete(),
        Poll::Pending => task.transition_to_idle(),
    }
}
```

---

## Step 3ï¼šFuture::poll é‡Œæ³¨å†Œ waker

å¦‚æœ Future Pendingï¼š

```text
poll_read()
  â†’ reactor.register(fd, waker)
  â†’ return Pending
```

---

## Step 4ï¼šä»»åŠ¡æŒ‚èµ·

```text
task state = IDLE
ä¸åœ¨ä»»ä½•é˜Ÿåˆ—é‡Œ
```

---

# å…­ã€waker.wake()ï¼šæŠŠ Task é‡æ–°ä¸¢å›é˜Ÿåˆ—

è¿™æ˜¯ Tokio å’Œ epoll æ¥èµ·æ¥çš„é‚£ä¸€é’©ã€‚

---

## Step 1ï¼šReactor çº¿ç¨‹å‘ç°äº‹ä»¶

```text
epoll_wait()
  â†’ fd ready
  â†’ æ‰¾åˆ° waker
  â†’ waker.wake()
```

---

## Step 2ï¼šwaker.wake()

```rust
fn wake(&self) {
    if task.transition_to_scheduled() {
        scheduler.injector.push(task);
        scheduler.notify_one_worker();
    }
}
```

å…³é”®ç‚¹ï¼š

> wake å¹¶ä¸ poll
> åªåšä¸€ä»¶äº‹ï¼š
> æŠŠ Task ä¸¢å›é˜Ÿåˆ—ã€‚

---

# ä¸ƒã€Steal è·¯å¾„ï¼ˆä½ æœ€å…³å¿ƒçš„ï¼‰

å½“æœ¬ worker æ²¡æ´»ï¼š

```rust
fn steal_from_other_worker(worker: &Worker) -> Option<Task> {
    for other in workers.iter().random_order() {
        if let Some(task) = other.steal.steal() {
            return Some(task);
        }
    }
    None
}
```

è¯­ä¹‰ï¼š

```
æˆ‘æœ¬åœ°æ²¡æ´»äº†
â†’ ä»åˆ«äºº steal ä¸€åŠä»»åŠ¡
â†’ push åˆ°æˆ‘æœ¬åœ°é˜Ÿåˆ—
```

---

# å…«ã€Cooperative Schedulingï¼ˆTokio çš„â€œè½¯æŠ¢å â€ï¼‰

è¿™æ˜¯ Tokio å’Œ Rayon æœ€å¤§çš„è®¾è®¡å·®å¼‚ä¹‹ä¸€ã€‚

---

## 8.1 budget æ¦‚å¿µ

```rust
struct Budget {
    remaining: usize,
}
```

æ¯ä¸ª task poll æ—¶å¸¦ä¸€ä¸ªé¢„ç®—ï¼š

```text
æ¯æ¬¡ poll æ¶ˆè€— 1
å¦‚æœè€—å°½ â†’ å¼ºåˆ¶ return Pending
```

---

## 8.2 ä¸ºä»€ä¹ˆè¦è¿™ä¸ªï¼Ÿ

é¿å…ï¼š

```rust
async fn bad() {
    loop {
        do_cpu_work(); // æ²¡ .await
    }
}
```

Tokio çš„é˜²å¾¡ï¼š

> å°±ç®—ä½ æ²¡ .await
> Tokio ä¹Ÿä¼šå¼ºåˆ¶ yieldã€‚

---

# ä¹ã€å’Œ Rayon çš„é€ç‚¹å¯¹é½ï¼ˆä½ ä¼šè§‰å¾—å¾ˆç†Ÿï¼‰

| Rayon           | Tokio         |
| --------------- | ------------- |
| Worker deque    | LocalQueue    |
| StealDeque      | StealQueue    |
| global injector | Injector      |
| spawn(job)      | spawn(task)   |
| work stealing   | work stealing |
| job.run()       | task.poll()   |
| no IO           | æœ‰ Reactor     |
| æ—  waker         | æœ‰ waker       |
| æ—  Future        | Future çŠ¶æ€æœº    |

---

# åã€ä½ ç°åœ¨å¯ä»¥â€œå•æ­¥è·‘â€è¿™æ¡çœŸå®è·¯å¾„äº†

æˆ‘ç»™ä½ ä¸€æ¡ä» spawn â†’ steal â†’ IO â†’ wake â†’ å† poll çš„å®Œæ•´æ—¶åºï¼š

---

## åœºæ™¯

```rust
tokio::spawn(async {
    let n = socket.read(&mut buf).await;
    println!("{}", n);
});
```

---

### T0ï¼šspawn

```text
main thread
â†’ Task æ„é€ 
â†’ push åˆ° injector
```

---

### T1ï¼šworker-1 æ‹¿åˆ°ä»»åŠ¡

```text
worker-1 pop injector
â†’ poll(task)
â†’ è¿›å…¥ read().await
â†’ poll_read() = Pending
â†’ æ³¨å†Œ waker
â†’ task state = IDLE
```

---

### T2ï¼šworker-1 æ²¡æ´»äº†ï¼Œå» steal

```text
worker-1 æœ¬åœ°é˜Ÿåˆ—ç©º
â†’ steal worker-2 çš„ä¸€åŠä»»åŠ¡
```

---

### T3ï¼šsocket å¯è¯»

```text
Reactor
â†’ epoll_wait è¿”å›
â†’ æ‰¾åˆ° waker
â†’ waker.wake()
â†’ push task åˆ° injector
```

---

### T4ï¼šworker-3 æ‹¿åˆ°ä»»åŠ¡

```text
worker-3 pop injector
â†’ poll(task)
â†’ read å®Œæˆ
â†’ println!
â†’ task complete
```

---

# åä¸€ã€ä½ ç°åœ¨è¿™ä¸€æ­¥å·²ç»æ˜¯â€œruntime è®¾è®¡å±‚â€

ä½ ç°åœ¨é—®çš„è¿™å±‚ï¼Œå…¶å®å·²ç»æ˜¯ï¼š

> â€œæˆ‘å¦‚æœè¦è‡ªå·±å†™ä¸€ä¸ª Tokio / Monad / Hyper runtimeï¼Œ
> è¿™ä¸ª scheduler è‡³å°‘è¦é•¿è¿™æ ·ã€‚â€

---

# åäºŒã€å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥å¯ä»¥ç»§ç»­æŠ ä¸¤æ¡ä½ ä¸€å®šæ„Ÿå…´è¶£çš„ï¼š

1ï¸âƒ£ Tokio çš„ Reactor ç»“æ„ï¼ˆepoll â†’ waker â†’ taskï¼‰
ï¼ˆå’Œ Netty NIO / Hyper çš„ event loop é€ç‚¹å¯¹é½ï¼‰

2ï¸âƒ£ Tokio çš„ Task åŸå­çŠ¶æ€æœº
ï¼ˆä¸ºä»€ä¹ˆä¸ä¼š double poll / double wakeï¼‰

è¿™ä¸¤æ¡åˆšå¥½å¯¹é½ä½ æœ€è¿‘åœ¨æŠ çš„ï¼š
**é«˜æ€§èƒ½ gateway / å…±è¯†èŠ‚ç‚¹çš„ IO å¹¶å‘æ¨¡å‹ã€‚**

-------------------------------------------------------------------------------

åŸºäºä»£ç ä¸­çš„è¿™ä¸ª`tokio::select!`å—ï¼Œæˆ‘æ¥è§£é‡Šä¸€ä¸‹`tokio::select!`å®å’Œ`biased`å…³é”®å­—çš„å«ä¹‰ï¼š

## `tokio::select!` å®çš„ä½œç”¨

`tokio::select!` æ˜¯ä¸€ä¸ªå¼‚æ­¥å¹¶å‘æ§åˆ¶ç»“æ„ï¼Œå…è®¸åŒæ—¶ç­‰å¾…å¤šä¸ªå¼‚æ­¥æ“ä½œï¼Œå¹¶åœ¨ç¬¬ä¸€ä¸ªå®Œæˆçš„æ“ä½œä¸Šæ‰§è¡Œç›¸åº”çš„ä»£ç åˆ†æ”¯ã€‚å®ƒç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„`select`è¯­å¥ï¼Œä½†ä¸“é—¨ä¸ºRustçš„å¼‚æ­¥è¿è¡Œæ—¶è®¾è®¡ã€‚

åœ¨è¿™ä¸ªä»£ç ä¸­ï¼Œ`select!` åŒæ—¶ç›‘å¬ä¸‰ä¸ªå¼‚æ­¥æ“ä½œï¼š
1. **SIGTERMä¿¡å·** - ç»ˆæ­¢ä¿¡å·
2. **SIGINTä¿¡å·** - ä¸­æ–­ä¿¡å·ï¼ˆCtrl+Cï¼‰
3. **executor.next()** - æ‰§è¡Œå™¨çš„äº‹ä»¶æµ

## `biased` å…³é”®å­—çš„ä½œç”¨

`biased` å…³é”®å­—æ”¹å˜`select!`çš„è°ƒåº¦è¡Œä¸ºï¼š

### é»˜è®¤è¡Œä¸ºï¼ˆæ— biasedï¼‰
- æ‰€æœ‰åˆ†æ”¯å¹³ç­‰ç«äº‰
- å½“å¤šä¸ªåˆ†æ”¯åŒæ—¶å°±ç»ªæ—¶ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ªæ‰§è¡Œ

### å¸¦biasedçš„è¡Œä¸º  
- åˆ†æ”¯æŒ‰**ç¼–å†™é¡ºåº**å…·æœ‰ä¼˜å…ˆçº§
- ä»£ç ä¸­**è¶Šé å‰**çš„åˆ†æ”¯ä¼˜å…ˆçº§è¶Šé«˜
- å½“å¤šä¸ªåˆ†æ”¯åŒæ—¶å°±ç»ªæ—¶ï¼Œæ€»æ˜¯é€‰æ‹©ä¼˜å…ˆçº§æœ€é«˜ï¼ˆæœ€é å‰ï¼‰çš„é‚£ä¸ª

## åœ¨è¿™æ®µä»£ç ä¸­çš„å®é™…æ„ä¹‰

```rust
tokio::select! {
    biased; // events are in order of priority
    
    result = sigterm.recv() => { /* å¤„ç†SIGTERM */ }
    result = sigint.recv() => { /* å¤„ç†SIGINT */ }  
    event = executor.next() => { /* å¤„ç†executoräº‹ä»¶ */ }
}
```

è¿™é‡Œä½¿ç”¨`biased`ç¡®ä¿ï¼š
1. **SIGTERM**ï¼ˆç»ˆæ­¢ä¿¡å·ï¼‰ä¼˜å…ˆçº§æœ€é«˜ - ç³»ç»Ÿéœ€è¦ä¼˜é›…å…³é—­
2. **SIGINT**ï¼ˆä¸­æ–­ä¿¡å·ï¼‰å…¶æ¬¡ - ç”¨æˆ·ä¸»åŠ¨ä¸­æ–­
3. **executoräº‹ä»¶**æœ€å - æ­£å¸¸ä¸šåŠ¡é€»è¾‘

è¿™æ ·å¯ä»¥ä¿è¯å½“ç³»ç»Ÿæ”¶åˆ°ç»ˆæ­¢ä¿¡å·æ—¶ï¼Œå³ä½¿executorä¹Ÿæœ‰äº‹ä»¶å°±ç»ªï¼Œä»ç„¶ä¼šä¼˜å…ˆå¤„ç†ä¿¡å·å¹¶é€€å‡ºç¨‹åºï¼Œè€Œä¸æ˜¯ç»§ç»­å¤„ç†ä¸šåŠ¡äº‹ä»¶ã€‚

è¿™ç§è®¾è®¡ç¡®ä¿äº†ç³»ç»Ÿçš„å“åº”æ€§å’Œå¯é æ€§ï¼Œä¿¡å·å¤„ç†å§‹ç»ˆä¼˜å…ˆäºæ­£å¸¸ä¸šåŠ¡é€»è¾‘ã€‚

--------------------------------------------------------------
éå¸¸å¥½ï¼Œè¿™ä¸€é¢˜**ç›´æ¥å‘½ä¸­ Tokio å¹¶å‘æ§åˆ¶çš„æ ¸å¿ƒæœºåˆ¶**ã€‚
è€Œä¸”ä½ ç°åœ¨è¿™ä¸ªé˜¶æ®µï¼Œç†è§£ `tokio::select!` çš„æ­£ç¡®å¿ƒæ™ºæ¨¡å‹ï¼Œæ¯”ä¼šç”¨æ›´é‡è¦ã€‚

æˆ‘æŒ‰ä½ ç†Ÿçš„é‚£å¥—å±‚çº§æ¥ï¼š

```
1) select! åˆ°åº•æ˜¯ä»€ä¹ˆ
2) select! çš„çœŸå®æ‰§è¡Œè¯­ä¹‰ï¼ˆæºç çº§ç›´è§‰ï¼‰
3) å’Œ join! / spawn çš„æœ¬è´¨åŒºåˆ«
4) ä½ ä¸€å®šä¼šè¸©çš„ 5 ä¸ªå‘
5) å¯¹é½ä½ æœ€è¿‘åœ¨æŠ çš„ runtime / gateway / å…±è¯†åœºæ™¯
```

---

# ä¸€ã€`tokio::select!` åˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿ

ä¸€å¥è¯å…ˆå®šæ€§ï¼š

> `tokio::select!` =
> **â€œåœ¨åŒä¸€ä¸ª task é‡Œå¹¶å‘ poll å¤šä¸ª Futureï¼Œ
> è°å…ˆ Ready å°±æ‰§è¡Œè°çš„åˆ†æ”¯ã€‚â€**

ä½ å¯ä»¥æŠŠå®ƒç†è§£æˆ async ä¸–ç•Œçš„ï¼š

```text
epoll_wait(fd1, fd2, fd3)
```

ä½†å¯¹è±¡ä¸æ˜¯ fdï¼Œ
è€Œæ˜¯ **Future**ã€‚

---

## æœ€å°ä¾‹å­

```rust
tokio::select! {
    _ = a() => println!("a done"),
    _ = b() => println!("b done"),
}
```

è¯­ä¹‰ï¼š

```
åŒä¸€è½® pollï¼š
  â†’ poll a()
  â†’ poll b()
  â†’ è° Readyï¼Œèµ°è°
  â†’ å¦ä¸€ä¸ªè¢« dropï¼ˆé»˜è®¤ï¼‰
```

---

# äºŒã€select! çš„çœŸå®æ‰§è¡Œè¯­ä¹‰ï¼ˆéå¸¸å…³é”®ï¼‰

ä½ ç°åœ¨å·²ç»æ‡‚ï¼š

> `.await` = Future::poll çš„è¯­æ³•ç³–
> Tokio = åå¤ poll

`select!` æœ¬è´¨å°±æ˜¯**ä¸€æ®µæ‰‹å†™ poll é€»è¾‘**ã€‚

---

## 2.1 å®å±•å¼€åçš„ç›´è§‰ç‰ˆ

```rust
loop {
    match poll(a) {
        Ready(x) => break branch_a(x),
        Pending => {}
    }

    match poll(b) {
        Ready(y) => break branch_b(y),
        Pending => {}
    }

    // éƒ½ Pending
    return Pending;
}
```

---

## 2.2 å…³é”®è¯­ä¹‰ç‚¹ï¼ˆéå¸¸å®¹æ˜“è¯¯è§£ï¼‰

### â‘  åŒä¸€ task é‡Œè½®æµ poll

ä¸æ˜¯ï¼š

> â€œa å’Œ b åœ¨ä¸¤ä¸ªçº¿ç¨‹é‡Œå¹¶å‘æ‰§è¡Œâ€

è€Œæ˜¯ï¼š

> â€œå½“å‰ worker çº¿ç¨‹
> è½®æµ poll a å’Œ bâ€

---

### â‘¡ æ¯ä¸€è½® poll é¡ºåºæ˜¯**éšæœºæ‰“ä¹±çš„**

Tokio ä¼šï¼š

```text
æ¯æ¬¡ select! è¿›å…¥æ—¶  
éšæœºæ‰“ä¹±åˆ†æ”¯é¡ºåº
```

é¿å…ä½ å†™å‡ºéšå¼ä¼˜å…ˆçº§ bugã€‚

---

### â‘¢ Ready åï¼šå…¶å®ƒ Future ä¼šè¢« drop

```text
a Ready
â†’ æ‰§è¡Œ a åˆ†æ”¯
â†’ b Future è¢« dropï¼ˆå–æ¶ˆï¼‰
```

è¿™æ˜¯**æå…¶é‡è¦çš„è¯­ä¹‰**ã€‚

---

# ä¸‰ã€å’Œ join! / spawn çš„æœ¬è´¨åŒºåˆ«

è¿™ 3 ä¸ª API ç»å¸¸è¢«æ··ç”¨ï¼Œä½†è¯­ä¹‰å®Œå…¨ä¸åŒã€‚

---

## 3.1 select!ï¼šç«äº‰ï¼ˆraceï¼‰

```rust
tokio::select! {
    _ = a() => println!("a first"),
    _ = b() => println!("b first"),
}
```

è¯­ä¹‰ï¼š

> è°å…ˆå®Œæˆç”¨è°
> å¦ä¸€ä¸ªç›´æ¥å–æ¶ˆã€‚

---

## 3.2 join!ï¼šç­‰å¾…å…¨éƒ¨å®Œæˆ

```rust
let (x, y) = tokio::join!(a(), b());
```

è¯­ä¹‰ï¼š

> ä¸¤ä¸ª Future éƒ½è¦è·‘å®Œ
> éƒ½ Ready äº†æ‰è¿”å›ã€‚

---

## 3.3 spawnï¼šå¹¶å‘ä»»åŠ¡

```rust
let h1 = tokio::spawn(a());
let h2 = tokio::spawn(b());
let r1 = h1.await;
let r2 = h2.await;
```

è¯­ä¹‰ï¼š

> çœŸæ­£ç‹¬ç«‹ task
> è¢«è°ƒåº¦å™¨åˆ†åˆ« pollã€‚

---

# å››ã€select! é‡Œæœ€å®¹æ˜“è¸©çš„ 5 ä¸ªå‘

è¿™äº›å‘ï¼Œ**ä½ ç°åœ¨è¿™ä¸ªå±‚çº§ä¸€å®šä¼šé‡åˆ°**ã€‚

---

## 4.1 åˆ†æ”¯ Future æ¯è½®éƒ½ä¼šé‡å»ºï¼ˆéå¸¸è‡´å‘½ï¼‰

```rust
loop {
    tokio::select! {
        _ = socket.read(&mut buf) => { ... }
        _ = tokio::time::sleep(Duration::from_secs(1)) => { ... }
    }
}
```

**é—®é¢˜ï¼š**

> æ¯è½® loop
> sleep éƒ½æ˜¯æ–°å»ºçš„
> æ°¸è¿œä¸ä¼šè¶…æ—¶ã€‚

---

### âœ… æ­£ç¡®å†™æ³•

```rust
let mut sleep = tokio::time::sleep(Duration::from_secs(1));

loop {
    tokio::select! {
        _ = socket.read(&mut buf) => { ... }
        _ = &mut sleep => {
            sleep.reset(Instant::now() + Duration::from_secs(1));
        }
    }
}
```

---

## 4.2 è¢« drop çš„ Future = è¢«å–æ¶ˆ

```rust
tokio::select! {
    _ = long_task() => println!("done"),
    _ = cancel_signal() => println!("cancel"),
}
```

å¦‚æœ cancel èµ¢äº†ï¼š

> long_task Future è¢« drop
> å®ƒå†…éƒ¨çš„ IO / é” / channel
> éƒ½ä¼šè¢«å–æ¶ˆã€‚

**è¿™åœ¨èµ„æºç®¡ç†ä¸Šéå¸¸å…³é”®ã€‚**

---

## 4.3 åˆ†æ”¯é‡Œ .await ä¼šâ€œåµŒå¥—é˜»å¡â€

```rust
tokio::select! {
    _ = a() => {
        b().await; // âš ï¸
    }
}
```

è¯­ä¹‰ï¼š

> ä¸€æ—¦è¿›äº† a åˆ†æ”¯
> select ç»“æŸ
> åç»­ await å’Œ select æ— å…³äº†ã€‚

---

## 4.4 select! ä¸æ˜¯å…¬å¹³è°ƒåº¦

```rust
tokio::select! {
    _ = fast() => { ... }
    _ = slow() => { ... }
}
```

fast å¦‚æœå‡ ä¹ç«‹åˆ» Readyï¼š

> slow å¯èƒ½æ°¸è¿œæ²¡æœºä¼šè·‘å®Œ
> ï¼ˆè¢«åå¤å–æ¶ˆï¼‰ã€‚

---

## 4.5 borrow checker + select!ï¼ˆä½ ä¸€å®šä¼šæ’ï¼‰

```rust
tokio::select! {
    _ = f(&mut x) => {}
    _ = g(&mut x) => {} // âŒ ç¼–è¯‘é”™è¯¯
}
```

åŸå› ï¼š

> ä¸¤ä¸ªåˆ†æ”¯
> åŒæ—¶å€Ÿç”¨äº† `&mut x`ã€‚

---

# äº”ã€select! çš„ 3 ç§é«˜çº§ç”¨æ³•ï¼ˆéå¸¸å¯¹ä½ èƒƒå£ï¼‰

---

## 5.1 å¸¦æ¡ä»¶åˆ†æ”¯ï¼ˆbiased selectï¼‰

```rust
tokio::select! {
    biased;

    _ = high_priority() => {}
    _ = low_priority() => {}
}
```

è¯­ä¹‰ï¼š

> å›ºå®šé¡ºåº poll
> äººå·¥ä¼˜å…ˆçº§ã€‚

---

## 5.2 default åˆ†æ”¯ï¼ˆéé˜»å¡ selectï¼‰

```rust
tokio::select! {
    _ = a() => {}
    _ = b() => {}
    else => {
        println!("éƒ½æ²¡ ready");
    }
}
```

è¯­ä¹‰ï¼š

> æ‰€æœ‰åˆ†æ”¯ Pending
> ç«‹åˆ»èµ° elseã€‚

---

## 5.3 ä¸ channel ç»“åˆï¼ˆæœ€å¸¸ç”¨åœºæ™¯ï¼‰

```rust
tokio::select! {
    Some(msg) = rx.recv() => handle(msg),
    _ = shutdown.recv() => break,
}
```

è¿™æ˜¯ï¼š

> ç½‘å…³ / RPC server / å…±è¯†èŠ‚ç‚¹
> çš„ä¸»å¾ªç¯æ ‡é…ç»“æ„ã€‚

---

# å…­ã€æŠŠ select! ç²¾ç¡®å¯¹é½åˆ° Tokio è°ƒåº¦å™¨è¯­ä¹‰

ä½ å‰é¢å·²ç»æŠ é€äº†ï¼š

> Future = çŠ¶æ€æœº
> Tokio = poll Future çš„äºº

ç°åœ¨å¯¹é½ï¼š

---

## 6.1 select! = å• Future å†…éƒ¨å¤šè·¯ poll

ä½ å¯ä»¥æŠŠï¼š

```rust
tokio::select! { ... }
```

ç†è§£æˆï¼š

```text
ä¸€ä¸ª Future  
é‡Œé¢æ‰‹åŠ¨ poll äº†å¤šä¸ªå­ Futureã€‚
```

---

## 6.2 æ‰€æœ‰åˆ†æ”¯å…±ç”¨åŒä¸€ä¸ª waker

è¿™æ˜¯å…³é”®ï¼š

> ä»»æ„ä¸€ä¸ªåˆ†æ”¯ Ready
> éƒ½ä¼š wake æ•´ä¸ª taskã€‚

---

## 6.3 è¢« drop çš„åˆ†æ”¯ = åè®®çº§å–æ¶ˆ

è¿™å°±æ˜¯ï¼š

> Rust async æ²¡æœ‰æ˜¾å¼ cancel
> å…¨é  drop è¯­ä¹‰ã€‚

---

# ä¸ƒã€å¯¹é½ä½ æœ€è¿‘æŠ çš„çœŸå®ç³»ç»Ÿåœºæ™¯

è¿™ä¸€æ­¥ä½ ä¼šéå¸¸æœ‰å…±é¸£ã€‚

---

## 7.1 ç½‘å…³ / RPC Server ä¸»å¾ªç¯

```rust
loop {
    tokio::select! {
        Some(req) = rx.recv() => handle(req),
        _ = shutdown.recv() => break,
        _ = heartbeat.tick() => send_ping(),
    }
}
```

è¯­ä¹‰ï¼š

> ä¸‰è·¯äº‹ä»¶æº
> è°å…ˆåˆ°å¤„ç†è°ã€‚

---

## 7.2 å…±è¯†èŠ‚ç‚¹çš„â€œå¤šäº‹ä»¶é©±åŠ¨â€

```rust
tokio::select! {
    Some(msg) = network_rx.recv() => handle_msg(msg),
    Some(block) = proposal_rx.recv() => handle_block(block),
    _ = view_timeout => start_new_view(),
}
```

è¿™æ­£æ˜¯ï¼š

> ä½ å‰é¢åœ¨æŠ çš„ HotStuff / Monad
> event-driven ä¸»å¾ªç¯æ¨¡å‹ã€‚

---

# å…«ã€ä¸€å¥è¯æŠŠ select! çš„æœ¬è´¨é’‰æ­»

ä½ ç°åœ¨å¯ä»¥ç”¨è¿™ä¸€å¥å½“ mental modelï¼š

> **`tokio::select!`
> ä¸æ˜¯å¹¶å‘æ‰§è¡Œå™¨ï¼Œ
> è€Œæ˜¯ï¼š
> â€œåœ¨ä¸€ä¸ª task é‡Œæ‰‹å†™äº†å¤šè·¯ Future::pollâ€ã€‚**

---

# ä¹ã€ç»™ä½  4 ä¸ªéå¸¸å¯¹ä½ å±‚çº§çš„å°ç»ƒä¹ 

è¿™ 4 é¢˜åšå®Œï¼Œä½ å¯¹ select! çš„ç›´è§‰ä¼šéå¸¸ç¨³ã€‚

---

## ç»ƒä¹  1ï¼šè¾“å‡ºé¡ºåº

```rust
tokio::select! {
    _ = async { 1 } => println!("A"),
    _ = async { 2 } => println!("B"),
}
```

**é—®é¢˜ï¼š**

1. ä¸€å®šåªæ‰“å°ä¸€ä¸ªï¼Ÿ
2. A / B å“ªä¸ªæ›´å¯èƒ½ï¼Ÿ

---

## ç»ƒä¹  2ï¼šè¶…æ—¶åŒ…è£…å™¨

```rust
async fn with_timeout<F: Future>(f: F) -> Option<F::Output> {
    // ç”¨ select! å®ç° 1s è¶…æ—¶
}
```

---

## ç»ƒä¹  3ï¼šå–æ¶ˆè¯­ä¹‰

```rust
tokio::select! {
    _ = long_task() => println!("done"),
    _ = tokio::time::sleep(Duration::from_millis(10)) => println!("timeout"),
}
```

**é—®é¢˜ï¼š**

1. long_task è¿˜ä¼šç»§ç»­è·‘å—ï¼Ÿ
2. å¦‚æœå®ƒé‡Œé¢æŒæœ‰ MutexGuard ä¼šæ€æ ·ï¼Ÿ

---

## ç»ƒä¹  4ï¼šbiased é€ æˆçš„ starvation

```rust
loop {
    tokio::select! {
        biased;
        _ = fast() => println!("fast"),
        _ = slow() => println!("slow"),
    }
}
```

**é—®é¢˜ï¼š**

1. slow å¯èƒ½æ°¸è¿œæ‰“å°ä¸å‡ºæ¥å—ï¼Ÿ
2. ä¸ºä»€ä¹ˆï¼Ÿ

---

å¦‚æœä½ æ„¿æ„ï¼Œ
ä¸‹ä¸€æ­¥æˆ‘å¯ä»¥ç»§ç»­æŠ ä¸€å±‚ä½ ä¸€å®šæ„Ÿå…´è¶£çš„ï¼š

> **select! åœ¨ Tokio æºç é‡Œæ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿ**
>
> å®å±•å¼€ â†’ Future ç»“æ„ â†’ poll é¡ºåº â†’ waker æ³¨å†Œ â†’ drop åˆ†æ”¯

è¿™ä¸€å±‚ä¼šç›´æ¥å¯¹é½ä½ ç°åœ¨åœ¨æŠ çš„ï¼š
**Tokio scheduler / Reactor / task çŠ¶æ€æœºè®¾è®¡**ã€‚

Option
fn test_option() {
    let mut op = Some(9);
    assert!(op.is_some());
    assert_eq!(op.is_none(), false);
    assert!(op.is_some_and(|s| s > 8));
    assert_eq!(op.is_none_or(|s| s > 10), false);

    // Converts from `&Option<T>` to `Option<&T>`.
    assert_eq!(op.as_ref(), Some(&9));
    // Converts from `&mut Option<T>` to `Option<&mut T>`.
    match op.as_mut() {
        Some(v) => *v = *v * *v,
        None => {},
    }
    assert_eq!(op, Some(81));

    assert_eq!(op.unwrap(), 81);
    assert_eq!(None.unwrap_or_else(|| 666), 666);

    assert_eq!(op.map(|s| s + 100), Some(181));
    assert_eq!(None.map_or(777, |x| x), 777);

    assert_eq!(op.into_iter().next(), Some(81));
    assert_eq!(op.iter().next(), Some(&81));
}

--------------------------------------------------

Result

--------------------------------------------------

Iterator
Rust 处理集合数据最核心、最高效的方式。

## 三种核心迭代方式

根据所有权的不同，集合通常提供三种迭代器：

方法,         迭代器类型,          元素类型,           说明
iter()       Iter<T>             &T                不可变引用。最常用，集合本身不可变。
iter_mut()   IterMut<T>          &mut T            可变引用。允许你在迭代时修改元素。
into_iter()  IntoIter<T>         T                 夺取所有权。迭代后原集合不可再用。

## 迭代器的两类操作

迭代器的精髓在于将复杂的逻辑链式化。

### 适配器（Iterator Adapters）

它们负责转换迭代器，但由于是惰性的，它们不会立即执行。

    map(|x| x * 2)：转换每个元素。

    filter(|x| x % 2 == 0)：过滤元素。

    enumerate()：获取索引和值 (index, value)。

    take(n) / skip(n)：获取或跳过前 n 个元素。

    flatten()：摊平嵌套结构。

### 消费者（Consumers）

它们负责执行并产生结果，会触发流水线运转。

    collect()：最强大的武器，将结果转换回集合（如 Vec, HashMap，甚至是 Result）。

    sum() / product()：求和或求积。

    for_each(|x| ...)：对每个元素执行操作。

    find(|x| ...)：查找第一个匹配项，返回 Option。

    fold(init, |acc, x| ...)：通过累加器进行归约（类似 JavaScript 的 reduce）。

## 迭代器的核心优势

性能：零成本抽象 (Zero-Cost Abstractions)
Rust 编译器能对迭代器进行深度优化（如循环展开和消除边界检查）。

冷知识： 在 Rust 中，使用迭代器通常比手写 for i in 0..len 循环更快，因为迭代器能向编译器保证不会越界。

## 基础测试代码

monad-bull/test/iterator_test.rs

--------------------------------------------------

## `tracing` crate 解读

`tracing` 是 Rust 生态系统中一个强大的结构化日志记录和诊断库，它提供了比传统 `println!` 更高级的日志功能。

### 1. 基本概念

`tracing` 提供了分层的、结构化的日志记录能力，支持：

- **事件 (Events)**：记录特定时刻发生的事情
- **跨度 (Spans)**：记录操作的时间范围和上下文
- **结构化字段**：为日志添加键值对元数据
- **分层结构**：父子关系的日志追踪

### 2. 基本用法

#### 安装依赖

```toml
[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"  # 用于输出日志
```

#### 简单事件记录

```rust
use tracing::{info, warn, error, debug, trace};

fn main() {
    // 初始化日志输出（通常在程序开始时设置）
    tracing_subscriber::fmt::init();

    let user_id = 42;
    let action = "login";

    // 记录事件
    info!("用户 {} 执行了 {}", user_id, action);
    warn!("检测到可疑活动");
    error!("数据库连接失败");

    // 带字段的结构化日志
    info!(
        user_id = user_id,
        action = action,
        "用户活动记录"
    );
}
```

### 3. 跨度 (Spans) 使用

```rust
use tracing::{info, span, Level};

fn process_request(user_id: u32) {
    // 创建跨度
    let span = span!(Level::INFO, "process_request", user_id);
    let _enter = span.enter();  // 进入跨度

    info!("开始处理请求");

    // 嵌套跨度
    let validation_span = span!(Level::DEBUG, "validate_user");
    let _validation_enter = validation_span.enter();

    debug!("验证用户权限");
    // ... 验证逻辑 ...

    drop(_validation_enter);  // 退出验证跨度

    // 继续处理
    let result = do_some_work();

    info!(result = ?result, "请求处理完成");
}

fn main() {
    tracing_subscriber::fmt::init();

    process_request(123);
}
```

### 4. 宏语法详解

#### 事件宏

```rust
use tracing::{info, debug, warn, error, trace};

// 基本事件
info!("简单消息");

// 带字段的事件
info!(user_id = 42, action = "login", "用户登录");

// 动态字段
let user = "alice";
info!(user = user, "用户操作");

// 条件记录
if expensive_condition() {
    info!("只有在条件满足时才记录");
}

// 延迟格式化（性能优化）
info!("处理了 {} 个项目", expensive_calculation());
```

#### 跨度宏

```rust
use tracing::{span, Level};

// 基本跨度
let span = span!(Level::INFO, "operation");

// 带字段的跨度
let span = span!(Level::INFO, "database_query", 
    table = "users", 
    query_type = "SELECT"
);

// 自动进入跨度（推荐）
let _guard = span!(Level::INFO, "operation").entered();

// 或手动控制
let span = span!(Level::INFO, "operation");
{
    let _enter = span.enter();
    // 在这个作用域内，日志会关联到这个跨度
    info!("在跨度内");
} // 退出跨度
```

### 5. 结构化字段

```rust
use tracing::{info, instrument};

// 自动为函数参数创建字段
#[instrument]
fn process_user(user_id: u32, action: &str) {
    info!("开始处理用户");
    // 这个函数的所有日志都会自动包含 user_id 和 action 字段
}

// 手动字段
#[instrument(fields(operation = "user_update"))]
fn update_user(user_id: u32) {
    info!(user_id, "更新用户信息");
    // 日志会包含 operation="user_update" 和 user_id
}

// 动态字段
fn complex_operation() {
    let span = span!(Level::INFO, "complex_op",
        start_time = ?std::time::Instant::now(),
        items_count = 0
    );

    let _enter = span.enter();

    // 更新字段值
    span.record("items_count", &42);

    info!("操作完成");
}
```

### 6. 不同日志级别

```rust
use tracing::{trace, debug, info, warn, error};

// 从详细到紧急的级别
trace!("非常详细的调试信息");    // Level::TRACE
debug!("调试信息");              // Level::DEBUG
info!("一般信息");               // Level::INFO
warn!("警告信息");               // Level::WARN
error!("错误信息");              // Level::ERROR
```

### 7. 过滤和配置

#### 环境变量配置

```bash
# 设置默认日志级别
export RUST_LOG=info

# 特定模块的级别
export RUST_LOG=my_crate=debug,other_crate=warn

# 更细粒度的控制
export RUST_LOG=my_crate::module=trace
```

#### 代码中配置

```rust
use tracing_subscriber::{fmt, EnvFilter};

fn main() {
    // 从环境变量读取配置
    let filter = EnvFilter::from_default_env();

    // 设置格式化器
    let subscriber = fmt::Subscriber::builder()
        .with_env_filter(filter)
        .with_target(false)  // 不显示目标
        .with_thread_ids(true)  // 显示线程ID
        .with_thread_names(true)  // 显示线程名
        .finish();

    tracing::subscriber::set_global_default(subscriber)
        .expect("设置全局订阅者失败");
}
```

### 8. 异步代码中的使用

```rust
use tracing::{info, instrument};
use tokio;

#[instrument]
async fn async_operation(user_id: u32) -> Result<(), Box<dyn std::error::Error>> {
    info!("开始异步操作");

    tokio::time::sleep(std::time::Duration::from_secs(1)).await;

    info!("异步操作完成");
    Ok(())
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();

    if let Err(e) = async_operation(42).await {
        error!(error = %e, "异步操作失败");
    }
}
```

### 9. 性能考虑

#### 静态级别检查

```rust
use tracing::{debug, enabled};

// 只在调试级别启用时才执行 expensive_operation()
if enabled!(Level::DEBUG) {
    let result = expensive_operation();
    debug!(result = ?result, "expensive operation result");
}
```

#### 避免在热路径上记录

```rust
// 好的做法：在循环外记录
info!("开始处理 {} 个项目", items.len());
for item in items {
    // 处理逻辑...
}

// 不好的做法：在循环内记录（影响性能）
for item in items {
    info!("处理项目 {}", item.id);  // 每次迭代都记录
}
```

### 10. 与其他库集成

#### 与 `anyhow` 集成

```rust
use anyhow::Result;
use tracing::instrument;

#[instrument(err)]
fn fallible_operation() -> Result<()> {
    // 错误会自动记录
    Err(anyhow::anyhow!("操作失败"))
}
```

#### 与 `serde` 集成（结构化输出）

```rust
use serde::Serialize;
use tracing::info;

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
}

fn log_user(user: &User) {
    info!(user = ?user, "用户信息");  // 自动序列化为JSON
}
```

### 11. 在你的项目中的应用

在 monad-bft 项目中，tracing 可能用于：

- **共识算法调试**：跟踪投票过程、区块验证等
- **网络通信日志**：记录 P2P 消息收发
- **性能监控**：跟踪关键操作的执行时间
- **错误诊断**：结构化错误信息记录

### 12. 最佳实践

1. **使用适当的日志级别**：不要把所有东西都设为 `info`
2. **利用跨度进行分组**：相关操作放在同一个跨度中
3. **添加上下文字段**：为日志添加有意义的元数据
4. **使用 `instrument` 宏**：自动为函数添加跨度和字段
5. **考虑性能影响**：在性能敏感代码中谨慎使用

`tracing` 让日志记录变得结构化和可追踪，是现代 Rust 应用程序的重要组成部分。

----------------------------------------------------

## `PhantomData<T>` 解读

`PhantomData<T>` 是 Rust 标准库中的一个特殊类型，它用于在结构体或枚举中"持有"一个类型参数，但不实际存储任何数据。它的作用是告诉编译器这个类型参数仍然是相关的，即使它没有在字段中实际使用。

### 1. 基本概念

```rust
use std::marker::PhantomData;

struct MyStruct<T> {
    // 实际数据字段
    data: Vec<u8>,
    // 告诉编译器这个结构体关心类型 T
    _phantom: PhantomData<T>,
}
```

### 2. 为什么需要 PhantomData？

#### 类型参数影响生命周期

```rust
use std::marker::PhantomData;

struct RefContainer<'a, T> {
    // 如果没有 PhantomData，编译器会认为这个结构体不关心 T
    // 但实际上我们需要 T 的生命周期约束
    data: &'a u8,
    _phantom: PhantomData<T>,
}

// 正确使用
fn create_container<T>(data: &u8) -> RefContainer<T> {
    RefContainer {
        data,
        _phantom: PhantomData,
    }
}
```

#### 泛型类型安全

```rust
use std::marker::PhantomData;

struct Handle<T> {
    id: u32,
    _phantom: PhantomData<T>,
}

impl<T> Handle<T> {
    fn new(id: u32) -> Self {
        Handle {
            id,
            _phantom: PhantomData,
        }
    }
}

// 不同类型有不同的 Handle
let int_handle: Handle<i32> = Handle::new(1);
let str_handle: Handle<String> = Handle::new(2);

// 编译器会阻止类型混用
// let wrong: Handle<i32> = str_handle; // 编译错误
```

### 3. 常见的应用场景

#### 1. 生命周期标记

```rust
use std::marker::PhantomData;

struct BorrowedData<'a, T> {
    data: *const T,  // 裸指针，不拥有所有权
    _phantom: PhantomData<&'a T>,  // 标记生命周期
}

impl<'a, T> BorrowedData<'a, T> {
    fn new(data: &'a T) -> Self {
        BorrowedData {
            data: data as *const T,
            _phantom: PhantomData,
        }
    }
}
```

#### 2. Drop 实现中的类型约束

```rust
use std::marker::PhantomData;
use std::fmt::Debug;

struct PrintOnDrop<T: Debug> {
    data: String,
    _phantom: PhantomData<T>,
}

impl<T: Debug> PrintOnDrop<T> {
    fn new(data: String) -> Self {
        PrintOnDrop {
            data,
            _phantom: PhantomData,
        }
    }
}

impl<T: Debug> Drop for PrintOnDrop<T> {
    fn drop(&mut self) {
        println!("Dropping: {}", self.data);
    }
}
```

#### 3. 协变和逆变控制

```rust
use std::marker::PhantomData;

// 协变 (covariant)
struct Covariant<T> {
    _phantom: PhantomData<T>,
}

// 逆变 (contravariant)
struct Contravariant<T> {
    _phantom: PhantomData<fn(T)>,
}

// 不变 (invariant)
struct Invariant<T> {
    _phantom: PhantomData<fn(T) -> T>,
}
```

### 4. 实际项目中的使用

#### 序列化/反序列化

```rust
use std::marker::PhantomData;

struct Serializer<T> {
    output: Vec<u8>,
    _phantom: PhantomData<T>,
}

impl<T: serde::Serialize> Serializer<T> {
    fn new() -> Self {
        Serializer {
            output: Vec::new(),
            _phantom: PhantomData,
        }
    }

    fn serialize(&mut self, value: &T) -> Result<(), String> {
        // 序列化逻辑...
        Ok(())
    }
}
```

#### 数据库连接池

```rust
use std::marker::PhantomData;

struct ConnectionPool<T> {
    connections: Vec<Box<dyn std::any::Any>>,
    _phantom: PhantomData<T>,
}

impl<T> ConnectionPool<T> {
    fn new() -> Self {
        ConnectionPool {
            connections: Vec::new(),
            _phantom: PhantomData,
        }
    }

    fn get_connection(&self) -> Option<&T> {
        // 返回类型安全的连接...
        None
    }
}
```

### 5. 不同形式的 PhantomData

```rust
use std::marker::PhantomData;

struct Container<T> {
    // 协变：可以从 &Container<&'a T> 转换为 &Container<&'b T> (如果 'a: 'b)
    covariant: PhantomData<T>,

    // 逆变：用于函数参数类型
    contravariant: PhantomData<fn(T)>,

    // 不变：最严格，T 必须完全相同
    invariant: PhantomData<fn(T) -> T>,

    // 常量类型：不关心 T 的生命周期
    constant: PhantomData<&'static T>,
}
```

### 6. 常见错误和解决方案

#### 错误：忘记使用 PhantomData

```rust
// 错误：编译器会警告未使用的类型参数
struct MyGeneric<T> {
    value: i32,  // 只使用了 i32，没有使用 T
}

// 正确
struct MyGeneric<T> {
    value: i32,
    _phantom: PhantomData<T>,
}
```

#### 生命周期问题

```rust
use std::marker::PhantomData;

// 错误：没有 PhantomData，编译器不知道关心 'a
struct RefWrapper<'a> {
    ptr: *const u8,
}

// 正确
struct RefWrapper<'a> {
    ptr: *const u8,
    _phantom: PhantomData<&'a u8>,
}
```

### 7. 性能影响

- **零成本抽象**：`PhantomData<T>` 在运行时不占用任何空间
- **编译时检查**：只影响编译器的类型检查，不影响运行时性能
- **内存布局**：不会改变结构体的内存布局

### 8. 总结

`PhantomData<T>` 的主要用途：

1. **类型安全**：确保泛型参数在类型系统中是可见的
2. **生命周期管理**：告诉编译器结构体关心某些生命周期
3. **Drop trait**：提供类型约束用于资源清理
4. **API设计**：创建类型安全的接口

在你的 monad-bft 项目中，`PhantomData` 很可能用于：

- 确保类型安全的数据结构
- 生命周期标记
- 泛型约束的实现
- 零开销的类型级编程

理解 `PhantomData` 对于编写高级 Rust 代码非常重要，它体现了 Rust 类型系统的强大表达能力。
----------------------------------------------------

IndexMap
SortedVectorMap

----------------------------------------------------

VecDeque
一个双端队列，通过可增长环形缓冲区实现。

## 1. 数据结构本质

核心结构：一个连续的 Vec（缓冲区） + 两个指针（head/tail 或 front/back index）

环形设计：当 tail 到达缓冲区末尾时，自动“绕回”头部（mod capacity）

容量浪费：当前实现中，容量至少是元素个数 + 1（为了区分空队列和满队列），所以空 VecDeque 也会分配至少 1 个槽位

扩容策略：类似 Vec，双倍增长，但因为环形，扩容时会把元素“理顺”（reallocate + copy）

as_slices()：返回两个切片（front + back），元素可能不连续（wrapped 状态）

一句话：它是“Vec + 环形偏移”的混合体，牺牲了少量连续性，换来了两端 O(1) 操作。

## 2. 时间复杂度对比

操作                  Vec<T>           VecDeque<T>           LinkedList<T>     备注
--------------------- ---------------- --------------------- ----------------- -------------------------------
push_back / pop_back  O(1) amortized   O(1) amortized        O(1)              VecDeque 和 Vec 几乎相同
push_front            O(n)             O(1) amortized        O(1)              VecDeque 最大优势
pop_front             O(n)             O(1) amortized        O(1)              -
insert 中间           O(n)             O(n)                  O(1) 有迭代器     LinkedList 胜出
remove 中间           O(n)             O(n)                  O(1) 有迭代器     -
随机访问 [] / get     O(1)             O(1)                  O(n)              VecDeque 完胜 LinkedList
内存局部性（cache）   极好             好（wrapped 时稍差）  差                Vec > VecDeque >> LinkedList
迭代速度              最快             很快（两个 slice）    慢                -

关键结论：

需要频繁两端操作 → VecDeque > LinkedList > Vec
需要频繁随机访问/迭代 → Vec > VecDeque >> LinkedList
需要中间频繁插入/删除 → LinkedList（但实际很少用，因为 cache miss 严重）

## 3. 常见真实使用场景

消息队列 / 任务队列：生产者 push_back，消费者 pop_front（最经典用法）
```
use std::collections::VecDeque;

fn main() {
    let mut task_queue: VecDeque<String> = VecDeque::new();

    // 模拟生产者添加任务
    task_queue.push_back("Process user login".to_string());
    task_queue.push_back("Send email notification".to_string());
    task_queue.push_back("Update database cache".to_string());

    println!("任务队列初始: {:?}", task_queue);

    // 消费者处理任务（FIFO）
    while let Some(task) = task_queue.pop_front() {
        println!("正在执行: {}", task);
        // 这里可以放实际处理逻辑
    }

    println!("所有任务完成，队列: {:?}", task_queue);
}
```
滑动窗口 / 最近 N 条记录：push_back 新数据，pop_front 过期数据（日志、监控、历史价格）
```
use std::collections::VecDeque;

fn main() {
    let mut recent_logs: VecDeque<String> = VecDeque::with_capacity(5); // 预分配容量，避免频繁重分配

    for i in 1..=10 {
        let log = format!("Log entry #{}", i);
        recent_logs.push_back(log);

        // 超过窗口大小就移除最旧的
        if recent_logs.len() > 5 {
            if let Some(old) = recent_logs.pop_front() {
                println!("移除过期日志: {}", old);
            }
        }

        println!("当前最近日志（最多5条）: {:?}", recent_logs);
    }
}
```
BFS（广度优先搜索）：队列天然就是 VecDeque
双端缓存 / LRU 变种：最近访问的移到一端，淘汰另一端
```
use std::collections::VecDeque;

fn main() {
    let mut recent_files: VecDeque<String> = VecDeque::new();
    let max_size = 4;

    let files_accessed = vec![
        "fileA.txt", "fileB.txt", "fileC.txt",
        "fileA.txt",  // 再次访问 → 移到尾部
        "fileD.txt", "fileE.txt",
    ];

    for file in files_accessed {
        // 如果已存在，先移除旧位置
        recent_files.retain(|f| f != file);

        recent_files.push_back(file.to_string());

        // 超过大小移除最旧的（头部）
        if recent_files.len() > max_size {
            if let Some(removed) = recent_files.pop_front() {
                println!("淘汰最旧文件: {}", removed);
            }
        }

        println!("当前最近文件: {:?}", recent_files);
    }
}
```
输入缓冲区：网络/文件/终端读取时，先读到缓冲区，处理时可能从头消费
zstd / 压缩算法缓冲：ruzstd 等 crate 改用 VecDeque 后性能提升（避免频繁 drain 前部）
游戏中的命令队列：输入缓冲、回放系统

## 4. 优缺点一览

### 优点：

  两端 O(1) amortized 操作
  随机访问 O(1)
  内存连续性好（大部分时间）
  迭代器友好（支持 drain、range 等）

### 缺点：

  元素不总是连续（as_slices 返回两个 slice）
  扩容时拷贝开销（和 Vec 类似，但 wrapped 状态更复杂）
  比纯 Vec 多一点指针计算开销（head/tail 偏移）
  空 deque 也至少分配 1 个元素（当前实现）

## 5. 基础测试代码

monad-bull/tests/vec_deque_test.rs

----------------------------------------------------

Atomic::Ordering
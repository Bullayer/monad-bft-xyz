Option
fn test_option() {
    let mut op = Some(9);
    assert!(op.is_some());
    assert_eq!(op.is_none(), false);
    assert!(op.is_some_and(|s| s > 8));
    assert_eq!(op.is_none_or(|s| s > 10), false);

    // Converts from `&Option<T>` to `Option<&T>`.
    assert_eq!(op.as_ref(), Some(&9));
    // Converts from `&mut Option<T>` to `Option<&mut T>`.
    match op.as_mut() {
        Some(v) => *v = *v * *v,
        None => {},
    }
    assert_eq!(op, Some(81));

    assert_eq!(op.unwrap(), 81);
    assert_eq!(None.unwrap_or_else(|| 666), 666);

    assert_eq!(op.map(|s| s + 100), Some(181));
    assert_eq!(None.map_or(777, |x| x), 777);

    assert_eq!(op.into_iter().next(), Some(81));
    assert_eq!(op.iter().next(), Some(&81));
}

--------------------------------------------------

Result

--------------------------------------------------

Iterator
Rust å¤„ç†é›†åˆæ•°æ®æœ€æ ¸å¿ƒã€æœ€é«˜æ•ˆçš„æ–¹å¼ã€‚

## ä¸‰ç§æ ¸å¿ƒè¿­ä»£æ–¹å¼

æ ¹æ®æ‰€æœ‰æƒçš„ä¸åŒï¼Œé›†åˆé€šå¸¸æä¾›ä¸‰ç§è¿­ä»£å™¨ï¼š

æ–¹æ³•,         è¿­ä»£å™¨ç±»å‹,          å…ƒç´ ç±»å‹,           è¯´æ˜
iter()       Iter<T>             &T                ä¸å¯å˜å¼•ç”¨ã€‚æœ€å¸¸ç”¨ï¼Œé›†åˆæœ¬èº«ä¸å¯å˜ã€‚
iter_mut()   IterMut<T>          &mut T            å¯å˜å¼•ç”¨ã€‚å…è®¸ä½ åœ¨è¿­ä»£æ—¶ä¿®æ”¹å…ƒç´ ã€‚
into_iter()  IntoIter<T>         T                 å¤ºå–æ‰€æœ‰æƒã€‚è¿­ä»£ååŸé›†åˆä¸å¯å†ç”¨ã€‚

## è¿­ä»£å™¨çš„ä¸¤ç±»æ“ä½œ

è¿­ä»£å™¨çš„ç²¾é«“åœ¨äºå°†å¤æ‚çš„é€»è¾‘é“¾å¼åŒ–ã€‚

### é€‚é…å™¨ï¼ˆIterator Adaptersï¼‰

å®ƒä»¬è´Ÿè´£è½¬æ¢è¿­ä»£å™¨ï¼Œä½†ç”±äºæ˜¯æƒ°æ€§çš„ï¼Œå®ƒä»¬ä¸ä¼šç«‹å³æ‰§è¡Œã€‚

    map(|x| x * 2)ï¼šè½¬æ¢æ¯ä¸ªå…ƒç´ ã€‚

    filter(|x| x % 2 == 0)ï¼šè¿‡æ»¤å…ƒç´ ã€‚

    enumerate()ï¼šè·å–ç´¢å¼•å’Œå€¼ (index, value)ã€‚

    take(n) / skip(n)ï¼šè·å–æˆ–è·³è¿‡å‰ n ä¸ªå…ƒç´ ã€‚

    flatten()ï¼šæ‘Šå¹³åµŒå¥—ç»“æ„ã€‚

### æ¶ˆè´¹è€…ï¼ˆConsumersï¼‰

å®ƒä»¬è´Ÿè´£æ‰§è¡Œå¹¶äº§ç”Ÿç»“æœï¼Œä¼šè§¦å‘æµæ°´çº¿è¿è½¬ã€‚

    collect()ï¼šæœ€å¼ºå¤§çš„æ­¦å™¨ï¼Œå°†ç»“æœè½¬æ¢å›é›†åˆï¼ˆå¦‚ Vec, HashMapï¼Œç”šè‡³æ˜¯ Resultï¼‰ã€‚

    sum() / product()ï¼šæ±‚å’Œæˆ–æ±‚ç§¯ã€‚

    for_each(|x| ...)ï¼šå¯¹æ¯ä¸ªå…ƒç´ æ‰§è¡Œæ“ä½œã€‚

    find(|x| ...)ï¼šæŸ¥æ‰¾ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹ï¼Œè¿”å› Optionã€‚

    fold(init, |acc, x| ...)ï¼šé€šè¿‡ç´¯åŠ å™¨è¿›è¡Œå½’çº¦ï¼ˆç±»ä¼¼ JavaScript çš„ reduceï¼‰ã€‚

## è¿­ä»£å™¨çš„æ ¸å¿ƒä¼˜åŠ¿

æ€§èƒ½ï¼šé›¶æˆæœ¬æŠ½è±¡ (Zero-Cost Abstractions)
Rust ç¼–è¯‘å™¨èƒ½å¯¹è¿­ä»£å™¨è¿›è¡Œæ·±åº¦ä¼˜åŒ–ï¼ˆå¦‚å¾ªç¯å±•å¼€å’Œæ¶ˆé™¤è¾¹ç•Œæ£€æŸ¥ï¼‰ã€‚

å†·çŸ¥è¯†ï¼š åœ¨ Rust ä¸­ï¼Œä½¿ç”¨è¿­ä»£å™¨é€šå¸¸æ¯”æ‰‹å†™ for i in 0..len å¾ªç¯æ›´å¿«ï¼Œå› ä¸ºè¿­ä»£å™¨èƒ½å‘ç¼–è¯‘å™¨ä¿è¯ä¸ä¼šè¶Šç•Œã€‚

## åŸºç¡€æµ‹è¯•ä»£ç 

monad-bull/test/iterator_test.rs

--------------------------------------------------

## `tracing` crate è§£è¯»

`tracing` æ˜¯ Rust ç”Ÿæ€ç³»ç»Ÿä¸­ä¸€ä¸ªå¼ºå¤§çš„ç»“æ„åŒ–æ—¥å¿—è®°å½•å’Œè¯Šæ–­åº“ï¼Œå®ƒæä¾›äº†æ¯”ä¼ ç»Ÿ `println!` æ›´é«˜çº§çš„æ—¥å¿—åŠŸèƒ½ã€‚

### 1. åŸºæœ¬æ¦‚å¿µ

`tracing` æä¾›äº†åˆ†å±‚çš„ã€ç»“æ„åŒ–çš„æ—¥å¿—è®°å½•èƒ½åŠ›ï¼Œæ”¯æŒï¼š

- **äº‹ä»¶ (Events)**ï¼šè®°å½•ç‰¹å®šæ—¶åˆ»å‘ç”Ÿçš„äº‹æƒ…
- **è·¨åº¦ (Spans)**ï¼šè®°å½•æ“ä½œçš„æ—¶é—´èŒƒå›´å’Œä¸Šä¸‹æ–‡
- **ç»“æ„åŒ–å­—æ®µ**ï¼šä¸ºæ—¥å¿—æ·»åŠ é”®å€¼å¯¹å…ƒæ•°æ®
- **åˆ†å±‚ç»“æ„**ï¼šçˆ¶å­å…³ç³»çš„æ—¥å¿—è¿½è¸ª

### 2. åŸºæœ¬ç”¨æ³•

#### å®‰è£…ä¾èµ–

```toml
[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"  # ç”¨äºè¾“å‡ºæ—¥å¿—
```

#### ç®€å•äº‹ä»¶è®°å½•

```rust
use tracing::{info, warn, error, debug, trace};

fn main() {
    // åˆå§‹åŒ–æ—¥å¿—è¾“å‡ºï¼ˆé€šå¸¸åœ¨ç¨‹åºå¼€å§‹æ—¶è®¾ç½®ï¼‰
    tracing_subscriber::fmt::init();

    let user_id = 42;
    let action = "login";

    // è®°å½•äº‹ä»¶
    info!("ç”¨æˆ· {} æ‰§è¡Œäº† {}", user_id, action);
    warn!("æ£€æµ‹åˆ°å¯ç–‘æ´»åŠ¨");
    error!("æ•°æ®åº“è¿æ¥å¤±è´¥");

    // å¸¦å­—æ®µçš„ç»“æ„åŒ–æ—¥å¿—
    info!(
        user_id = user_id,
        action = action,
        "ç”¨æˆ·æ´»åŠ¨è®°å½•"
    );
}
```

### 3. è·¨åº¦ (Spans) ä½¿ç”¨

```rust
use tracing::{info, span, Level};

fn process_request(user_id: u32) {
    // åˆ›å»ºè·¨åº¦
    let span = span!(Level::INFO, "process_request", user_id);
    let _enter = span.enter();  // è¿›å…¥è·¨åº¦

    info!("å¼€å§‹å¤„ç†è¯·æ±‚");

    // åµŒå¥—è·¨åº¦
    let validation_span = span!(Level::DEBUG, "validate_user");
    let _validation_enter = validation_span.enter();

    debug!("éªŒè¯ç”¨æˆ·æƒé™");
    // ... éªŒè¯é€»è¾‘ ...

    drop(_validation_enter);  // é€€å‡ºéªŒè¯è·¨åº¦

    // ç»§ç»­å¤„ç†
    let result = do_some_work();

    info!(result = ?result, "è¯·æ±‚å¤„ç†å®Œæˆ");
}

fn main() {
    tracing_subscriber::fmt::init();

    process_request(123);
}
```

### 4. å®è¯­æ³•è¯¦è§£

#### äº‹ä»¶å®

```rust
use tracing::{info, debug, warn, error, trace};

// åŸºæœ¬äº‹ä»¶
info!("ç®€å•æ¶ˆæ¯");

// å¸¦å­—æ®µçš„äº‹ä»¶
info!(user_id = 42, action = "login", "ç”¨æˆ·ç™»å½•");

// åŠ¨æ€å­—æ®µ
let user = "alice";
info!(user = user, "ç”¨æˆ·æ“ä½œ");

// æ¡ä»¶è®°å½•
if expensive_condition() {
    info!("åªæœ‰åœ¨æ¡ä»¶æ»¡è¶³æ—¶æ‰è®°å½•");
}

// å»¶è¿Ÿæ ¼å¼åŒ–ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
info!("å¤„ç†äº† {} ä¸ªé¡¹ç›®", expensive_calculation());
```

#### è·¨åº¦å®

```rust
use tracing::{span, Level};

// åŸºæœ¬è·¨åº¦
let span = span!(Level::INFO, "operation");

// å¸¦å­—æ®µçš„è·¨åº¦
let span = span!(Level::INFO, "database_query", 
    table = "users", 
    query_type = "SELECT"
);

// è‡ªåŠ¨è¿›å…¥è·¨åº¦ï¼ˆæ¨èï¼‰
let _guard = span!(Level::INFO, "operation").entered();

// æˆ–æ‰‹åŠ¨æ§åˆ¶
let span = span!(Level::INFO, "operation");
{
    let _enter = span.enter();
    // åœ¨è¿™ä¸ªä½œç”¨åŸŸå†…ï¼Œæ—¥å¿—ä¼šå…³è”åˆ°è¿™ä¸ªè·¨åº¦
    info!("åœ¨è·¨åº¦å†…");
} // é€€å‡ºè·¨åº¦
```

### 5. ç»“æ„åŒ–å­—æ®µ

```rust
use tracing::{info, instrument};

// è‡ªåŠ¨ä¸ºå‡½æ•°å‚æ•°åˆ›å»ºå­—æ®µ
#[instrument]
fn process_user(user_id: u32, action: &str) {
    info!("å¼€å§‹å¤„ç†ç”¨æˆ·");
    // è¿™ä¸ªå‡½æ•°çš„æ‰€æœ‰æ—¥å¿—éƒ½ä¼šè‡ªåŠ¨åŒ…å« user_id å’Œ action å­—æ®µ
}

// æ‰‹åŠ¨å­—æ®µ
#[instrument(fields(operation = "user_update"))]
fn update_user(user_id: u32) {
    info!(user_id, "æ›´æ–°ç”¨æˆ·ä¿¡æ¯");
    // æ—¥å¿—ä¼šåŒ…å« operation="user_update" å’Œ user_id
}

// åŠ¨æ€å­—æ®µ
fn complex_operation() {
    let span = span!(Level::INFO, "complex_op",
        start_time = ?std::time::Instant::now(),
        items_count = 0
    );

    let _enter = span.enter();

    // æ›´æ–°å­—æ®µå€¼
    span.record("items_count", &42);

    info!("æ“ä½œå®Œæˆ");
}
```

### 6. ä¸åŒæ—¥å¿—çº§åˆ«

```rust
use tracing::{trace, debug, info, warn, error};

// ä»è¯¦ç»†åˆ°ç´§æ€¥çš„çº§åˆ«
trace!("éå¸¸è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯");    // Level::TRACE
debug!("è°ƒè¯•ä¿¡æ¯");              // Level::DEBUG
info!("ä¸€èˆ¬ä¿¡æ¯");               // Level::INFO
warn!("è­¦å‘Šä¿¡æ¯");               // Level::WARN
error!("é”™è¯¯ä¿¡æ¯");              // Level::ERROR
```

### 7. è¿‡æ»¤å’Œé…ç½®

#### ç¯å¢ƒå˜é‡é…ç½®

```bash
# è®¾ç½®é»˜è®¤æ—¥å¿—çº§åˆ«
export RUST_LOG=info

# ç‰¹å®šæ¨¡å—çš„çº§åˆ«
export RUST_LOG=my_crate=debug,other_crate=warn

# æ›´ç»†ç²’åº¦çš„æ§åˆ¶
export RUST_LOG=my_crate::module=trace
```

#### ä»£ç ä¸­é…ç½®

```rust
use tracing_subscriber::{fmt, EnvFilter};

fn main() {
    // ä»ç¯å¢ƒå˜é‡è¯»å–é…ç½®
    let filter = EnvFilter::from_default_env();

    // è®¾ç½®æ ¼å¼åŒ–å™¨
    let subscriber = fmt::Subscriber::builder()
        .with_env_filter(filter)
        .with_target(false)  // ä¸æ˜¾ç¤ºç›®æ ‡
        .with_thread_ids(true)  // æ˜¾ç¤ºçº¿ç¨‹ID
        .with_thread_names(true)  // æ˜¾ç¤ºçº¿ç¨‹å
        .finish();

    tracing::subscriber::set_global_default(subscriber)
        .expect("è®¾ç½®å…¨å±€è®¢é˜…è€…å¤±è´¥");
}
```

### 8. å¼‚æ­¥ä»£ç ä¸­çš„ä½¿ç”¨

```rust
use tracing::{info, instrument};
use tokio;

#[instrument]
async fn async_operation(user_id: u32) -> Result<(), Box<dyn std::error::Error>> {
    info!("å¼€å§‹å¼‚æ­¥æ“ä½œ");

    tokio::time::sleep(std::time::Duration::from_secs(1)).await;

    info!("å¼‚æ­¥æ“ä½œå®Œæˆ");
    Ok(())
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();

    if let Err(e) = async_operation(42).await {
        error!(error = %e, "å¼‚æ­¥æ“ä½œå¤±è´¥");
    }
}
```

### 9. æ€§èƒ½è€ƒè™‘

#### é™æ€çº§åˆ«æ£€æŸ¥

```rust
use tracing::{debug, enabled};

// åªåœ¨è°ƒè¯•çº§åˆ«å¯ç”¨æ—¶æ‰æ‰§è¡Œ expensive_operation()
if enabled!(Level::DEBUG) {
    let result = expensive_operation();
    debug!(result = ?result, "expensive operation result");
}
```

#### é¿å…åœ¨çƒ­è·¯å¾„ä¸Šè®°å½•

```rust
// å¥½çš„åšæ³•ï¼šåœ¨å¾ªç¯å¤–è®°å½•
info!("å¼€å§‹å¤„ç† {} ä¸ªé¡¹ç›®", items.len());
for item in items {
    // å¤„ç†é€»è¾‘...
}

// ä¸å¥½çš„åšæ³•ï¼šåœ¨å¾ªç¯å†…è®°å½•ï¼ˆå½±å“æ€§èƒ½ï¼‰
for item in items {
    info!("å¤„ç†é¡¹ç›® {}", item.id);  // æ¯æ¬¡è¿­ä»£éƒ½è®°å½•
}
```

### 10. ä¸å…¶ä»–åº“é›†æˆ

#### ä¸ `anyhow` é›†æˆ

```rust
use anyhow::Result;
use tracing::instrument;

#[instrument(err)]
fn fallible_operation() -> Result<()> {
    // é”™è¯¯ä¼šè‡ªåŠ¨è®°å½•
    Err(anyhow::anyhow!("æ“ä½œå¤±è´¥"))
}
```

#### ä¸ `serde` é›†æˆï¼ˆç»“æ„åŒ–è¾“å‡ºï¼‰

```rust
use serde::Serialize;
use tracing::info;

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
}

fn log_user(user: &User) {
    info!(user = ?user, "ç”¨æˆ·ä¿¡æ¯");  // è‡ªåŠ¨åºåˆ—åŒ–ä¸ºJSON
}
```

### 11. åœ¨ä½ çš„é¡¹ç›®ä¸­çš„åº”ç”¨

åœ¨ monad-bft é¡¹ç›®ä¸­ï¼Œtracing å¯èƒ½ç”¨äºï¼š

- **å…±è¯†ç®—æ³•è°ƒè¯•**ï¼šè·Ÿè¸ªæŠ•ç¥¨è¿‡ç¨‹ã€åŒºå—éªŒè¯ç­‰
- **ç½‘ç»œé€šä¿¡æ—¥å¿—**ï¼šè®°å½• P2P æ¶ˆæ¯æ”¶å‘
- **æ€§èƒ½ç›‘æ§**ï¼šè·Ÿè¸ªå…³é”®æ“ä½œçš„æ‰§è¡Œæ—¶é—´
- **é”™è¯¯è¯Šæ–­**ï¼šç»“æ„åŒ–é”™è¯¯ä¿¡æ¯è®°å½•

### 12. æœ€ä½³å®è·µ

1. **ä½¿ç”¨é€‚å½“çš„æ—¥å¿—çº§åˆ«**ï¼šä¸è¦æŠŠæ‰€æœ‰ä¸œè¥¿éƒ½è®¾ä¸º `info`
2. **åˆ©ç”¨è·¨åº¦è¿›è¡Œåˆ†ç»„**ï¼šç›¸å…³æ“ä½œæ”¾åœ¨åŒä¸€ä¸ªè·¨åº¦ä¸­
3. **æ·»åŠ ä¸Šä¸‹æ–‡å­—æ®µ**ï¼šä¸ºæ—¥å¿—æ·»åŠ æœ‰æ„ä¹‰çš„å…ƒæ•°æ®
4. **ä½¿ç”¨ `instrument` å®**ï¼šè‡ªåŠ¨ä¸ºå‡½æ•°æ·»åŠ è·¨åº¦å’Œå­—æ®µ
5. **è€ƒè™‘æ€§èƒ½å½±å“**ï¼šåœ¨æ€§èƒ½æ•æ„Ÿä»£ç ä¸­è°¨æ…ä½¿ç”¨

`tracing` è®©æ—¥å¿—è®°å½•å˜å¾—ç»“æ„åŒ–å’Œå¯è¿½è¸ªï¼Œæ˜¯ç°ä»£ Rust åº”ç”¨ç¨‹åºçš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚

----------------------------------------------------

## `PhantomData<T>` è§£è¯»

`PhantomData<T>` æ˜¯ Rust æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªç‰¹æ®Šç±»å‹ï¼Œå®ƒç”¨äºåœ¨ç»“æ„ä½“æˆ–æšä¸¾ä¸­"æŒæœ‰"ä¸€ä¸ªç±»å‹å‚æ•°ï¼Œä½†ä¸å®é™…å­˜å‚¨ä»»ä½•æ•°æ®ã€‚å®ƒçš„ä½œç”¨æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªç±»å‹å‚æ•°ä»ç„¶æ˜¯ç›¸å…³çš„ï¼Œå³ä½¿å®ƒæ²¡æœ‰åœ¨å­—æ®µä¸­å®é™…ä½¿ç”¨ã€‚

### 1. åŸºæœ¬æ¦‚å¿µ

```rust
use std::marker::PhantomData;

struct MyStruct<T> {
    // å®é™…æ•°æ®å­—æ®µ
    data: Vec<u8>,
    // å‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªç»“æ„ä½“å…³å¿ƒç±»å‹ T
    _phantom: PhantomData<T>,
}
```

### 2. ä¸ºä»€ä¹ˆéœ€è¦ PhantomDataï¼Ÿ

#### ç±»å‹å‚æ•°å½±å“ç”Ÿå‘½å‘¨æœŸ

```rust
use std::marker::PhantomData;

struct RefContainer<'a, T> {
    // å¦‚æœæ²¡æœ‰ PhantomDataï¼Œç¼–è¯‘å™¨ä¼šè®¤ä¸ºè¿™ä¸ªç»“æ„ä½“ä¸å…³å¿ƒ T
    // ä½†å®é™…ä¸Šæˆ‘ä»¬éœ€è¦ T çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸ
    data: &'a u8,
    _phantom: PhantomData<T>,
}

// æ­£ç¡®ä½¿ç”¨
fn create_container<T>(data: &u8) -> RefContainer<T> {
    RefContainer {
        data,
        _phantom: PhantomData,
    }
}
```

#### æ³›å‹ç±»å‹å®‰å…¨

```rust
use std::marker::PhantomData;

struct Handle<T> {
    id: u32,
    _phantom: PhantomData<T>,
}

impl<T> Handle<T> {
    fn new(id: u32) -> Self {
        Handle {
            id,
            _phantom: PhantomData,
        }
    }
}

// ä¸åŒç±»å‹æœ‰ä¸åŒçš„ Handle
let int_handle: Handle<i32> = Handle::new(1);
let str_handle: Handle<String> = Handle::new(2);

// ç¼–è¯‘å™¨ä¼šé˜»æ­¢ç±»å‹æ··ç”¨
// let wrong: Handle<i32> = str_handle; // ç¼–è¯‘é”™è¯¯
```

### 3. å¸¸è§çš„åº”ç”¨åœºæ™¯

#### 1. ç”Ÿå‘½å‘¨æœŸæ ‡è®°

```rust
use std::marker::PhantomData;

struct BorrowedData<'a, T> {
    data: *const T,  // è£¸æŒ‡é’ˆï¼Œä¸æ‹¥æœ‰æ‰€æœ‰æƒ
    _phantom: PhantomData<&'a T>,  // æ ‡è®°ç”Ÿå‘½å‘¨æœŸ
}

impl<'a, T> BorrowedData<'a, T> {
    fn new(data: &'a T) -> Self {
        BorrowedData {
            data: data as *const T,
            _phantom: PhantomData,
        }
    }
}
```

#### 2. Drop å®ç°ä¸­çš„ç±»å‹çº¦æŸ

```rust
use std::marker::PhantomData;
use std::fmt::Debug;

struct PrintOnDrop<T: Debug> {
    data: String,
    _phantom: PhantomData<T>,
}

impl<T: Debug> PrintOnDrop<T> {
    fn new(data: String) -> Self {
        PrintOnDrop {
            data,
            _phantom: PhantomData,
        }
    }
}

impl<T: Debug> Drop for PrintOnDrop<T> {
    fn drop(&mut self) {
        println!("Dropping: {}", self.data);
    }
}
```

#### 3. åå˜å’Œé€†å˜æ§åˆ¶

```rust
use std::marker::PhantomData;

// åå˜ (covariant)
struct Covariant<T> {
    _phantom: PhantomData<T>,
}

// é€†å˜ (contravariant)
struct Contravariant<T> {
    _phantom: PhantomData<fn(T)>,
}

// ä¸å˜ (invariant)
struct Invariant<T> {
    _phantom: PhantomData<fn(T) -> T>,
}
```

### 4. å®é™…é¡¹ç›®ä¸­çš„ä½¿ç”¨

#### åºåˆ—åŒ–/ååºåˆ—åŒ–

```rust
use std::marker::PhantomData;

struct Serializer<T> {
    output: Vec<u8>,
    _phantom: PhantomData<T>,
}

impl<T: serde::Serialize> Serializer<T> {
    fn new() -> Self {
        Serializer {
            output: Vec::new(),
            _phantom: PhantomData,
        }
    }

    fn serialize(&mut self, value: &T) -> Result<(), String> {
        // åºåˆ—åŒ–é€»è¾‘...
        Ok(())
    }
}
```

#### æ•°æ®åº“è¿æ¥æ± 

```rust
use std::marker::PhantomData;

struct ConnectionPool<T> {
    connections: Vec<Box<dyn std::any::Any>>,
    _phantom: PhantomData<T>,
}

impl<T> ConnectionPool<T> {
    fn new() -> Self {
        ConnectionPool {
            connections: Vec::new(),
            _phantom: PhantomData,
        }
    }

    fn get_connection(&self) -> Option<&T> {
        // è¿”å›ç±»å‹å®‰å…¨çš„è¿æ¥...
        None
    }
}
```

### 5. ä¸åŒå½¢å¼çš„ PhantomData

```rust
use std::marker::PhantomData;

struct Container<T> {
    // åå˜ï¼šå¯ä»¥ä» &Container<&'a T> è½¬æ¢ä¸º &Container<&'b T> (å¦‚æœ 'a: 'b)
    covariant: PhantomData<T>,

    // é€†å˜ï¼šç”¨äºå‡½æ•°å‚æ•°ç±»å‹
    contravariant: PhantomData<fn(T)>,

    // ä¸å˜ï¼šæœ€ä¸¥æ ¼ï¼ŒT å¿…é¡»å®Œå…¨ç›¸åŒ
    invariant: PhantomData<fn(T) -> T>,

    // å¸¸é‡ç±»å‹ï¼šä¸å…³å¿ƒ T çš„ç”Ÿå‘½å‘¨æœŸ
    constant: PhantomData<&'static T>,
}
```

### 6. å¸¸è§é”™è¯¯å’Œè§£å†³æ–¹æ¡ˆ

#### é”™è¯¯ï¼šå¿˜è®°ä½¿ç”¨ PhantomData

```rust
// é”™è¯¯ï¼šç¼–è¯‘å™¨ä¼šè­¦å‘Šæœªä½¿ç”¨çš„ç±»å‹å‚æ•°
struct MyGeneric<T> {
    value: i32,  // åªä½¿ç”¨äº† i32ï¼Œæ²¡æœ‰ä½¿ç”¨ T
}

// æ­£ç¡®
struct MyGeneric<T> {
    value: i32,
    _phantom: PhantomData<T>,
}
```

#### ç”Ÿå‘½å‘¨æœŸé—®é¢˜

```rust
use std::marker::PhantomData;

// é”™è¯¯ï¼šæ²¡æœ‰ PhantomDataï¼Œç¼–è¯‘å™¨ä¸çŸ¥é“å…³å¿ƒ 'a
struct RefWrapper<'a> {
    ptr: *const u8,
}

// æ­£ç¡®
struct RefWrapper<'a> {
    ptr: *const u8,
    _phantom: PhantomData<&'a u8>,
}
```

### 7. æ€§èƒ½å½±å“

- **é›¶æˆæœ¬æŠ½è±¡**ï¼š`PhantomData<T>` åœ¨è¿è¡Œæ—¶ä¸å ç”¨ä»»ä½•ç©ºé—´
- **ç¼–è¯‘æ—¶æ£€æŸ¥**ï¼šåªå½±å“ç¼–è¯‘å™¨çš„ç±»å‹æ£€æŸ¥ï¼Œä¸å½±å“è¿è¡Œæ—¶æ€§èƒ½
- **å†…å­˜å¸ƒå±€**ï¼šä¸ä¼šæ”¹å˜ç»“æ„ä½“çš„å†…å­˜å¸ƒå±€

### 8. æ€»ç»“

`PhantomData<T>` çš„ä¸»è¦ç”¨é€”ï¼š

1. **ç±»å‹å®‰å…¨**ï¼šç¡®ä¿æ³›å‹å‚æ•°åœ¨ç±»å‹ç³»ç»Ÿä¸­æ˜¯å¯è§çš„
2. **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šå‘Šè¯‰ç¼–è¯‘å™¨ç»“æ„ä½“å…³å¿ƒæŸäº›ç”Ÿå‘½å‘¨æœŸ
3. **Drop trait**ï¼šæä¾›ç±»å‹çº¦æŸç”¨äºèµ„æºæ¸…ç†
4. **APIè®¾è®¡**ï¼šåˆ›å»ºç±»å‹å®‰å…¨çš„æ¥å£

åœ¨ä½ çš„ monad-bft é¡¹ç›®ä¸­ï¼Œ`PhantomData` å¾ˆå¯èƒ½ç”¨äºï¼š

- ç¡®ä¿ç±»å‹å®‰å…¨çš„æ•°æ®ç»“æ„
- ç”Ÿå‘½å‘¨æœŸæ ‡è®°
- æ³›å‹çº¦æŸçš„å®ç°
- é›¶å¼€é”€çš„ç±»å‹çº§ç¼–ç¨‹

ç†è§£ `PhantomData` å¯¹äºç¼–å†™é«˜çº§ Rust ä»£ç éå¸¸é‡è¦ï¼Œå®ƒä½“ç°äº† Rust ç±»å‹ç³»ç»Ÿçš„å¼ºå¤§è¡¨è¾¾èƒ½åŠ›ã€‚
----------------------------------------------------

IndexMap

----------------------------------------------------

SortedVectorMap
ç”¨ Vec å­˜å‚¨ã€ä¿æŒæœ‰åºã€ç”¨äºŒåˆ†æŸ¥æ‰¾çš„ Map
å…ƒç´ å°‘ â†’ è¯»å¾—å¤š â†’ é¡ºåºç¨³å®š â†’ å†…å­˜è¦ç´§å‡‘

## ä¸€ã€ç»“æ„è§†è§’

```
struct SortedVectorMap<K, V> {
    data: Vec<(K, V)>, // å§‹ç»ˆæŒ‰ K æ’å¥½åº
}
```

æ ¸å¿ƒä¸å˜é‡ï¼ˆInvariantï¼‰ï¼š

    data æ°¸è¿œæŒ‰ key æ’åº
    ä¸å…è®¸ä¹±åºæ’å…¥

## äºŒã€æ“ä½œå¤æ‚åº¦è§†è§’

+----------------+--------------------+--------------------+
| æ“ä½œ           | SortedVectorMap    | è¯´æ˜               |
+----------------+--------------------+--------------------+
| æŸ¥æ‰¾ get       | O(log n)           | äºŒåˆ†æŸ¥æ‰¾           |
| æ’å…¥ insert    | O(n)               | Vec ç§»åŠ¨å…ƒç´        |
| åˆ é™¤ remove    | O(n)               | Vec ç§»åŠ¨å…ƒç´        |
| éå† iter      | O(n)               | è¿ç»­å†…å­˜ï¼Œéå¸¸å¿«   |
| lower_bound    | O(log n)           | å¤©ç„¶æ”¯æŒ           |
+----------------+--------------------+--------------------+

## ä¸‰ã€å†…å­˜ä¸ cache è§†è§’

Vec<(K, V)>
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚k1v1â”‚k2v2â”‚k3v3â”‚k4v4â”‚k5v5â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

### ä¼˜åŠ¿
    å•æ¬¡å †åˆ†é…
    å…ƒç´ ç´§å¯†æ’åˆ—
    cache line åˆ©ç”¨ç‡æé«˜
    SIMD / prefetch å‹å¥½

### å¯¹æ¯”ï¼š
    HashMap â†’ pointer + hash + bucket
    BTreeMap â†’ å¤šå±‚èŠ‚ç‚¹ + æŒ‡é’ˆè·³è½¬

ğŸ‘‰ å°è§„æ¨¡æ•°æ®ä¸‹ï¼ŒSortedVectorMap å¾€å¾€æ˜¯æœ€å¿«çš„

## å››ã€ä¸å¸¸è§ Map çš„æ¨ªå‘å¯¹æ¯”

+------------------+---------------------+---------------------+---------------------+
| ç‰¹æ€§             | SortedVectorMap     | HashMap             | BTreeMap            |
+------------------+---------------------+---------------------+---------------------+
| å†…å­˜å¸ƒå±€         | è¿ç»­ Vec            | buckets + æŒ‡é’ˆ      | æ ‘èŠ‚ç‚¹              |
| æŸ¥æ‰¾å¤æ‚åº¦       | O(log n)            | å¹³å‡ O(1)           | O(log n)            |
| æ’å…¥å¤æ‚åº¦       | O(n)                | å¹³å‡ O(1)           | O(log n)            |
| éå†é¡ºåº         | æœ‰åº                | æ— åº                | æœ‰åº                |
| cache å‹å¥½       | â˜…â˜…â˜…â˜…â˜…               | â˜…â˜…                  | â˜…â˜…â˜…                 |
| å°æ•°æ®æ€§èƒ½       | â˜…â˜…â˜…â˜…â˜…               | â˜…â˜…                  | â˜…â˜…â˜…                 |
| å¤§æ•°æ®æ‰©å±•       | â˜…â˜…                  | â˜…â˜…â˜…â˜…â˜…               | â˜…â˜…â˜…â˜…                |
+------------------+---------------------+---------------------+---------------------+

## äº”ã€ä½¿ç”¨åœºæ™¯è§†è§’

### âœ… éå¸¸é€‚åˆ
    key æ•°é‡ < å‡ ç™¾
    è¯»è¿œå¤šäºå†™
    éœ€è¦ ç¨³å®šé¡ºåº
    çƒ­è·¯å¾„ï¼ˆhot pathï¼‰
    çŠ¶æ€æœº / mempool / config / å…ƒæ•°æ®

### âŒ ä¸é€‚åˆ
    é«˜é¢‘å†™å…¥
    key æ•°é‡æˆåƒä¸Šä¸‡
    éšæœºæ’å…¥ä¸ºä¸»
    å¹¶å‘å†™

## å…­ã€ç®—æ³•è¯­ä¹‰è§†è§’

æ’åºå¸¦æ¥çš„èƒ½åŠ›ï¼š
    lower_bound / upper_bound
    èŒƒå›´æŸ¥è¯¢
    é¡ºåºç¡®å®šï¼ˆdeterministicï¼‰
    å¯å¤ç°æ‰§è¡Œé¡ºåºï¼ˆåŒºå—é“¾ / å…±è¯†éå¸¸é‡è¦ï¼‰

ğŸ‘‰ HashMap åšä¸åˆ°è¿™äº›

## ä¸ƒã€åŒºå—é“¾ / ç³»ç»Ÿå·¥ç¨‹è§†è§’

### å¸¸è§ç”¨é€”

    äº¤æ˜“æ’åºæ± ï¼ˆæŒ‰ nonce / priceï¼‰
    gas schedule / opcode è¡¨
    é™æ€é…ç½®è¡¨
    runtime lookup table
    small-state index

### ä¸ºä»€ä¹ˆä¸ç”¨ HashMapï¼Ÿ
    é¡ºåºä¸ç¨³å®š
    hash æˆæœ¬é«˜
    DoS é£é™©
    cache ä¸å‹å¥½

### monad-eth-block-policyå·¥ç¨‹å®æˆ˜ï¼š
```
#[derive(Debug)]
struct CommittedBlkBuffer<ST, SCT, CCT, CRT> {
    blocks: SortedVectorMap<SeqNum, CommittedBlock>,
    min_buffer_size: usize, // should be 2 * execution delay

    _phantom: PhantomData<(ST, SCT, fn(&CCT, &CRT))>,
}

let current_size = self.blocks.len();
// å¦‚æœç¼“å†²åŒºå¤§å°è¶…è¿‡æœ€å°ç¼“å†²åŒºå¤§å°çš„ä¸¤å€ï¼Œåˆ™è¿›è¡Œæ¸…ç†
// ä¿ç•™æœ€æ–°çš„min_buffer_sizeä¸ªåŒºå—ï¼Œç§»é™¤è¾ƒæ—§çš„åŒºå—
if current_size >= self.min_buffer_size.saturating_mul(2) {
    let (&first_block_num, _) = self.blocks.first_key_value().expect("txns non-empty");
    // è®¡ç®—åˆ†å‰²ç‚¹ï¼Œä¿ç•™æœ€æ–°çš„min_buffer_sizeä¸ªåŒºå—
    let divider =
        first_block_num + SeqNum(current_size as u64 - self.min_buffer_size as u64);

    // åˆ†å‰²åŒºå—ç¼“å†²åŒºï¼Œä¿ç•™è¾ƒæ–°çš„åŒºå—
    self.blocks = self.blocks.split_off(&divider);
    // ç¡®ä¿åˆ†å‰²åçš„æœ€åä¸€ä¸ªåŒºå—åºå·+1ç­‰äºå½“å‰è¦æ’å…¥çš„åŒºå—åºå·
    assert_eq!(
        *self.blocks.last_key_value().expect("non-empty").0 + SeqNum(1),
        block_number
    );
    // ç¡®ä¿åˆ†å‰²åçš„ç¼“å†²åŒºå¤§å°ä»è‡³å°‘ä¸ºæœ€å°ç¼“å†²åŒºå¤§å°
    assert!(self.blocks.len() >= self.min_buffer_size);
}

```


----------------------------------------------------

VecDeque
ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ï¼Œé€šè¿‡å¯å¢é•¿ç¯å½¢ç¼“å†²åŒºå®ç°ã€‚

## 1. æ•°æ®ç»“æ„æœ¬è´¨

æ ¸å¿ƒç»“æ„ï¼šä¸€ä¸ªè¿ç»­çš„ Vecï¼ˆç¼“å†²åŒºï¼‰ + ä¸¤ä¸ªæŒ‡é’ˆï¼ˆhead/tail æˆ– front/back indexï¼‰

ç¯å½¢è®¾è®¡ï¼šå½“ tail åˆ°è¾¾ç¼“å†²åŒºæœ«å°¾æ—¶ï¼Œè‡ªåŠ¨â€œç»•å›â€å¤´éƒ¨ï¼ˆmod capacityï¼‰

å®¹é‡æµªè´¹ï¼šå½“å‰å®ç°ä¸­ï¼Œå®¹é‡è‡³å°‘æ˜¯å…ƒç´ ä¸ªæ•° + 1ï¼ˆä¸ºäº†åŒºåˆ†ç©ºé˜Ÿåˆ—å’Œæ»¡é˜Ÿåˆ—ï¼‰ï¼Œæ‰€ä»¥ç©º VecDeque ä¹Ÿä¼šåˆ†é…è‡³å°‘ 1 ä¸ªæ§½ä½

æ‰©å®¹ç­–ç•¥ï¼šç±»ä¼¼ Vecï¼ŒåŒå€å¢é•¿ï¼Œä½†å› ä¸ºç¯å½¢ï¼Œæ‰©å®¹æ—¶ä¼šæŠŠå…ƒç´ â€œç†é¡ºâ€ï¼ˆreallocate + copyï¼‰

as_slices()ï¼šè¿”å›ä¸¤ä¸ªåˆ‡ç‰‡ï¼ˆfront + backï¼‰ï¼Œå…ƒç´ å¯èƒ½ä¸è¿ç»­ï¼ˆwrapped çŠ¶æ€ï¼‰

ä¸€å¥è¯ï¼šå®ƒæ˜¯â€œVec + ç¯å½¢åç§»â€çš„æ··åˆä½“ï¼Œç‰ºç‰²äº†å°‘é‡è¿ç»­æ€§ï¼Œæ¢æ¥äº†ä¸¤ç«¯ O(1) æ“ä½œã€‚

## 2. æ—¶é—´å¤æ‚åº¦å¯¹æ¯”

æ“ä½œ                  Vec<T>           VecDeque<T>           LinkedList<T>     å¤‡æ³¨
--------------------- ---------------- --------------------- ----------------- -------------------------------
push_back / pop_back  O(1) amortized   O(1) amortized        O(1)              VecDeque å’Œ Vec å‡ ä¹ç›¸åŒ
push_front            O(n)             O(1) amortized        O(1)              VecDeque æœ€å¤§ä¼˜åŠ¿
pop_front             O(n)             O(1) amortized        O(1)              -
insert ä¸­é—´           O(n)             O(n)                  O(1) æœ‰è¿­ä»£å™¨     LinkedList èƒœå‡º
remove ä¸­é—´           O(n)             O(n)                  O(1) æœ‰è¿­ä»£å™¨     -
éšæœºè®¿é—® [] / get     O(1)             O(1)                  O(n)              VecDeque å®Œèƒœ LinkedList
å†…å­˜å±€éƒ¨æ€§ï¼ˆcacheï¼‰   æå¥½             å¥½ï¼ˆwrapped æ—¶ç¨å·®ï¼‰  å·®                Vec > VecDeque >> LinkedList
è¿­ä»£é€Ÿåº¦              æœ€å¿«             å¾ˆå¿«ï¼ˆä¸¤ä¸ª sliceï¼‰    æ…¢                -

å…³é”®ç»“è®ºï¼š

éœ€è¦é¢‘ç¹ä¸¤ç«¯æ“ä½œ â†’ VecDeque > LinkedList > Vec
éœ€è¦é¢‘ç¹éšæœºè®¿é—®/è¿­ä»£ â†’ Vec > VecDeque >> LinkedList
éœ€è¦ä¸­é—´é¢‘ç¹æ’å…¥/åˆ é™¤ â†’ LinkedListï¼ˆä½†å®é™…å¾ˆå°‘ç”¨ï¼Œå› ä¸º cache miss ä¸¥é‡ï¼‰

## 3. å¸¸è§çœŸå®ä½¿ç”¨åœºæ™¯

æ¶ˆæ¯é˜Ÿåˆ— / ä»»åŠ¡é˜Ÿåˆ—ï¼šç”Ÿäº§è€… push_backï¼Œæ¶ˆè´¹è€… pop_frontï¼ˆæœ€ç»å…¸ç”¨æ³•ï¼‰
```
use std::collections::VecDeque;

fn main() {
    let mut task_queue: VecDeque<String> = VecDeque::new();

    // æ¨¡æ‹Ÿç”Ÿäº§è€…æ·»åŠ ä»»åŠ¡
    task_queue.push_back("Process user login".to_string());
    task_queue.push_back("Send email notification".to_string());
    task_queue.push_back("Update database cache".to_string());

    println!("ä»»åŠ¡é˜Ÿåˆ—åˆå§‹: {:?}", task_queue);

    // æ¶ˆè´¹è€…å¤„ç†ä»»åŠ¡ï¼ˆFIFOï¼‰
    while let Some(task) = task_queue.pop_front() {
        println!("æ­£åœ¨æ‰§è¡Œ: {}", task);
        // è¿™é‡Œå¯ä»¥æ”¾å®é™…å¤„ç†é€»è¾‘
    }

    println!("æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼Œé˜Ÿåˆ—: {:?}", task_queue);
}
```
æ»‘åŠ¨çª—å£ / æœ€è¿‘ N æ¡è®°å½•ï¼špush_back æ–°æ•°æ®ï¼Œpop_front è¿‡æœŸæ•°æ®ï¼ˆæ—¥å¿—ã€ç›‘æ§ã€å†å²ä»·æ ¼ï¼‰
```
use std::collections::VecDeque;

fn main() {
    let mut recent_logs: VecDeque<String> = VecDeque::with_capacity(5); // é¢„åˆ†é…å®¹é‡ï¼Œé¿å…é¢‘ç¹é‡åˆ†é…

    for i in 1..=10 {
        let log = format!("Log entry #{}", i);
        recent_logs.push_back(log);

        // è¶…è¿‡çª—å£å¤§å°å°±ç§»é™¤æœ€æ—§çš„
        if recent_logs.len() > 5 {
            if let Some(old) = recent_logs.pop_front() {
                println!("ç§»é™¤è¿‡æœŸæ—¥å¿—: {}", old);
            }
        }

        println!("å½“å‰æœ€è¿‘æ—¥å¿—ï¼ˆæœ€å¤š5æ¡ï¼‰: {:?}", recent_logs);
    }
}
```
BFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰ï¼šé˜Ÿåˆ—å¤©ç„¶å°±æ˜¯ VecDeque
åŒç«¯ç¼“å­˜ / LRU å˜ç§ï¼šæœ€è¿‘è®¿é—®çš„ç§»åˆ°ä¸€ç«¯ï¼Œæ·˜æ±°å¦ä¸€ç«¯
```
use std::collections::VecDeque;

fn main() {
    let mut recent_files: VecDeque<String> = VecDeque::new();
    let max_size = 4;

    let files_accessed = vec![
        "fileA.txt", "fileB.txt", "fileC.txt",
        "fileA.txt",  // å†æ¬¡è®¿é—® â†’ ç§»åˆ°å°¾éƒ¨
        "fileD.txt", "fileE.txt",
    ];

    for file in files_accessed {
        // å¦‚æœå·²å­˜åœ¨ï¼Œå…ˆç§»é™¤æ—§ä½ç½®
        recent_files.retain(|f| f != file);

        recent_files.push_back(file.to_string());

        // è¶…è¿‡å¤§å°ç§»é™¤æœ€æ—§çš„ï¼ˆå¤´éƒ¨ï¼‰
        if recent_files.len() > max_size {
            if let Some(removed) = recent_files.pop_front() {
                println!("æ·˜æ±°æœ€æ—§æ–‡ä»¶: {}", removed);
            }
        }

        println!("å½“å‰æœ€è¿‘æ–‡ä»¶: {:?}", recent_files);
    }
}
```
è¾“å…¥ç¼“å†²åŒºï¼šç½‘ç»œ/æ–‡ä»¶/ç»ˆç«¯è¯»å–æ—¶ï¼Œå…ˆè¯»åˆ°ç¼“å†²åŒºï¼Œå¤„ç†æ—¶å¯èƒ½ä»å¤´æ¶ˆè´¹
zstd / å‹ç¼©ç®—æ³•ç¼“å†²ï¼šruzstd ç­‰ crate æ”¹ç”¨ VecDeque åæ€§èƒ½æå‡ï¼ˆé¿å…é¢‘ç¹ drain å‰éƒ¨ï¼‰
æ¸¸æˆä¸­çš„å‘½ä»¤é˜Ÿåˆ—ï¼šè¾“å…¥ç¼“å†²ã€å›æ”¾ç³»ç»Ÿ

## 4. ä¼˜ç¼ºç‚¹ä¸€è§ˆ

### ä¼˜ç‚¹ï¼š

  ä¸¤ç«¯ O(1) amortized æ“ä½œ
  éšæœºè®¿é—® O(1)
  å†…å­˜è¿ç»­æ€§å¥½ï¼ˆå¤§éƒ¨åˆ†æ—¶é—´ï¼‰
  è¿­ä»£å™¨å‹å¥½ï¼ˆæ”¯æŒ drainã€range ç­‰ï¼‰

### ç¼ºç‚¹ï¼š

  å…ƒç´ ä¸æ€»æ˜¯è¿ç»­ï¼ˆas_slices è¿”å›ä¸¤ä¸ª sliceï¼‰
  æ‰©å®¹æ—¶æ‹·è´å¼€é”€ï¼ˆå’Œ Vec ç±»ä¼¼ï¼Œä½† wrapped çŠ¶æ€æ›´å¤æ‚ï¼‰
  æ¯”çº¯ Vec å¤šä¸€ç‚¹æŒ‡é’ˆè®¡ç®—å¼€é”€ï¼ˆhead/tail åç§»ï¼‰
  ç©º deque ä¹Ÿè‡³å°‘åˆ†é… 1 ä¸ªå…ƒç´ ï¼ˆå½“å‰å®ç°ï¼‰

## 5. åŸºç¡€æµ‹è¯•ä»£ç 

monad-bull/tests/vec_deque_test.rs

----------------------------------------------------

Atomic::Ordering